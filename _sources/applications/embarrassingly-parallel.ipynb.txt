{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"http://dask.readthedocs.io/en/latest/_images/dask_horizontal.svg\" \n",
    "     width=\"30%\" \n",
    "     align=right\n",
    "     alt=\"Dask logo\">\n",
    "\n",
    "# Embarrassingly parallel Workloads\n",
    "\n",
    "This notebook shows how to use Dask to parallelize embarrassingly parallel workloads where you want to apply one function to many pieces of data independently.  It will show three different ways of doing this with Dask:\n",
    "\n",
    "1. [dask.delayed](http://dask.pydata.org/en/latest/delayed.html) \n",
    "2. [concurrent.Futures](https://dask.pydata.org/en/latest/futures.html) \n",
    "3. [dask.bag](https://dask.pydata.org/en/latest/bag.html)\n",
    "\n",
    "This example focuses on using Dask for building large embarrassingly parallel computation as often seen in scientific communities and on High Performance Computing facilities, for example with Monte Carlo methods. This kind of simulation assume the following:\n",
    "\n",
    " - We have a function that runs a heavy computation given some parameters.\n",
    " - We need to compute this function on many different input parameters, each function call being independent.\n",
    " - We want to gather all the results in one place for further analysis."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Start Dask Client for Dashboard\n",
    "\n",
    "Starting the Dask Client will provide a dashboard which \n",
    "is useful to gain insight on the computation.  We will also need it for the\n",
    "Futures API part of this example. Moreover, as this kind of computation\n",
    "is often launched on super computer or in the Cloud, you will probably end\n",
    "up having to start a cluster and connect a client to scale.  See \n",
    "[dask-jobqueue](https://github.com/dask/dask-jobqueue),\n",
    "[dask-kubernetes](https://github.com/dask/dask-kubernetes) or \n",
    "[dask-yarn](https://github.com/dask/dask-yarn) for easy ways to achieve this\n",
    "on respectively an HPC, Cloud or Big Data infrastructure.\n",
    "\n",
    "The link to the dashboard will become visible when you create the client below.  We recommend having it open on one side of your screen while using your notebook on the other side.  This can take some effort to arrange your windows, but seeing them both at the same time is very useful when learning."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:46.075167Z",
     "iopub.status.busy": "2021-07-19T14:36:46.074400Z",
     "iopub.status.idle": "2021-07-19T14:36:47.375690Z",
     "shell.execute_reply": "2021-07-19T14:36:47.375221Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<table style=\"border: 2px solid white;\">\n",
       "<tr>\n",
       "<td style=\"vertical-align: top; border: 0px solid white\">\n",
       "<h3 style=\"text-align: left;\">Client</h3>\n",
       "<ul style=\"text-align: left; list-style: none; margin: 0; padding: 0;\">\n",
       "  <li><b>Scheduler: </b>tcp://127.0.0.1:33827</li>\n",
       "  <li><b>Dashboard: </b><a href='http://127.0.0.1:8787/status' target='_blank'>http://127.0.0.1:8787/status</a></li>\n",
       "</ul>\n",
       "</td>\n",
       "<td style=\"vertical-align: top; border: 0px solid white\">\n",
       "<h3 style=\"text-align: left;\">Cluster</h3>\n",
       "<ul style=\"text-align: left; list-style:none; margin: 0; padding: 0;\">\n",
       "  <li><b>Workers: </b>1</li>\n",
       "  <li><b>Cores: </b>4</li>\n",
       "  <li><b>Memory: </b>7.29 GB</li>\n",
       "</ul>\n",
       "</td>\n",
       "</tr>\n",
       "</table>"
      ],
      "text/plain": [
       "<Client: 'tcp://127.0.0.1:33827' processes=1 threads=4, memory=7.29 GB>"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from dask.distributed import Client, progress\n",
    "client = Client(threads_per_worker=4, n_workers=1)\n",
    "client"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define your computation calling function\n",
    "\n",
    "This function does a simple operation: add all numbers of a list/array together, but it also sleeps for a random amount of time to simulate real work. In real use cases, this could call another python module, or even run an executable using subprocess module."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:47.379132Z",
     "iopub.status.busy": "2021-07-19T14:36:47.378729Z",
     "iopub.status.idle": "2021-07-19T14:36:47.381335Z",
     "shell.execute_reply": "2021-07-19T14:36:47.381636Z"
    }
   },
   "outputs": [],
   "source": [
    "import time\n",
    "import random\n",
    "\n",
    "def costly_simulation(list_param):\n",
    "    time.sleep(random.random())\n",
    "    return sum(list_param)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We try it locally below"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:47.384897Z",
     "iopub.status.busy": "2021-07-19T14:36:47.384492Z",
     "iopub.status.idle": "2021-07-19T14:36:48.349781Z",
     "shell.execute_reply": "2021-07-19T14:36:48.349419Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 11.6 ms, sys: 8.8 ms, total: 20.4 ms\n",
      "Wall time: 959 ms\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time costly_simulation([1, 2, 3, 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define the set of input parameters to call the function\n",
    "\n",
    "We will generate a set of inputs on which we want to run our simulation function. Here we use Pandas dataframe, but we could also use a simple list. Lets say that our simulation is run with four parameters called param_[a-d]."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:48.358201Z",
     "iopub.status.busy": "2021-07-19T14:36:48.353578Z",
     "iopub.status.idle": "2021-07-19T14:36:48.365140Z",
     "shell.execute_reply": "2021-07-19T14:36:48.365475Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>param_a</th>\n",
       "      <th>param_b</th>\n",
       "      <th>param_c</th>\n",
       "      <th>param_d</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0.876209</td>\n",
       "      <td>0.284124</td>\n",
       "      <td>0.787294</td>\n",
       "      <td>0.618808</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.291265</td>\n",
       "      <td>0.772789</td>\n",
       "      <td>0.126278</td>\n",
       "      <td>0.388665</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.467770</td>\n",
       "      <td>0.576193</td>\n",
       "      <td>0.750010</td>\n",
       "      <td>0.714852</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0.769100</td>\n",
       "      <td>0.614919</td>\n",
       "      <td>0.610101</td>\n",
       "      <td>0.484446</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0.926336</td>\n",
       "      <td>0.783289</td>\n",
       "      <td>0.446797</td>\n",
       "      <td>0.538244</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    param_a   param_b   param_c   param_d\n",
       "0  0.876209  0.284124  0.787294  0.618808\n",
       "1  0.291265  0.772789  0.126278  0.388665\n",
       "2  0.467770  0.576193  0.750010  0.714852\n",
       "3  0.769100  0.614919  0.610101  0.484446\n",
       "4  0.926336  0.783289  0.446797  0.538244"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "input_params = pd.DataFrame(np.random.random(size=(500, 4)),\n",
    "                            columns=['param_a', 'param_b', 'param_c', 'param_d'])\n",
    "input_params.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Without using Dask, we could call our simulation on all of these parameters using normal Python for loops.\n",
    "\n",
    "Let's only do this on a sample of our parameters as it would be quite long otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:48.368144Z",
     "iopub.status.busy": "2021-07-19T14:36:48.367750Z",
     "iopub.status.idle": "2021-07-19T14:36:48.369639Z",
     "shell.execute_reply": "2021-07-19T14:36:48.369233Z"
    }
   },
   "outputs": [],
   "source": [
    "results = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:48.372661Z",
     "iopub.status.busy": "2021-07-19T14:36:48.372233Z",
     "iopub.status.idle": "2021-07-19T14:36:53.718180Z",
     "shell.execute_reply": "2021-07-19T14:36:53.717812Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 105 ms, sys: 10.9 ms, total: 116 ms\n",
      "Wall time: 5.34 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "for parameters in input_params.values[:10]:\n",
    "    result = costly_simulation(parameters)\n",
    "    results.append(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:53.721920Z",
     "iopub.status.busy": "2021-07-19T14:36:53.721523Z",
     "iopub.status.idle": "2021-07-19T14:36:53.725815Z",
     "shell.execute_reply": "2021-07-19T14:36:53.725480Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[2.5664358075745453,\n",
       " 1.5789964258345153,\n",
       " 2.508826448170943,\n",
       " 2.478565462410365,\n",
       " 2.694666023301526,\n",
       " 2.183767178412362,\n",
       " 1.7393850063843117,\n",
       " 2.788475491010723,\n",
       " 1.7912832645048304,\n",
       " 2.330989678770308]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that this is not very clever as we can easily parallelize code. \n",
    "\n",
    "There are many ways to parallelize this function in Python with libraries like `multiprocessing`, `concurrent.futures`, `joblib` or others.  These are good first steps.  Dask is a good second step, especially when you want to scale across many machines.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Use [Dask Delayed](http://dask.pydata.org/en/latest/delayed.html) to make our function lazy\n",
    "\n",
    "We can call `dask.delayed` on our funtion to make it lazy.  Rather than compute its result immediately, it records what we want to compute as a task into a graph that we'll run later on parallel hardware. Using `dask.delayed` is a relatively straightforward way to parallelize an existing code base, even if the computation isn't embarrassingly parallel like this one. \n",
    "\n",
    "Calling these lazy functions is now almost free.  In the cell below we only construct a simple graph."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:53.729076Z",
     "iopub.status.busy": "2021-07-19T14:36:53.728241Z",
     "iopub.status.idle": "2021-07-19T14:36:53.730647Z",
     "shell.execute_reply": "2021-07-19T14:36:53.730958Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask\n",
    "lazy_results = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:53.734973Z",
     "iopub.status.busy": "2021-07-19T14:36:53.734580Z",
     "iopub.status.idle": "2021-07-19T14:36:53.740976Z",
     "shell.execute_reply": "2021-07-19T14:36:53.741396Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 494 µs, sys: 101 µs, total: 595 µs\n",
      "Wall time: 600 µs\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "for parameters in input_params.values[:10]:\n",
    "    lazy_result = dask.delayed(costly_simulation)(parameters)\n",
    "    lazy_results.append(lazy_result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:53.744031Z",
     "iopub.status.busy": "2021-07-19T14:36:53.743650Z",
     "iopub.status.idle": "2021-07-19T14:36:53.749894Z",
     "shell.execute_reply": "2021-07-19T14:36:53.750655Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Delayed('costly_simulation-3fc2998d-ee65-4e5a-a151-9ebba26121e1')"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lazy_results[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Run in parallel\n",
    "\n",
    "The `lazy_results` list contains information about ten calls to `costly_simulation` that have not yet been run.  Call `.compute()` when you want your result as normal Python objects.\n",
    "\n",
    "If you started `Client()` above then you may want to watch the status page during computation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:53.754966Z",
     "iopub.status.busy": "2021-07-19T14:36:53.754583Z",
     "iopub.status.idle": "2021-07-19T14:36:55.534184Z",
     "shell.execute_reply": "2021-07-19T14:36:55.533813Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 54.1 ms, sys: 6.19 ms, total: 60.3 ms\n",
      "Wall time: 1.77 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(2.5664358075745453,\n",
       " 1.5789964258345153,\n",
       " 2.508826448170943,\n",
       " 2.478565462410365,\n",
       " 2.694666023301526,\n",
       " 2.183767178412362,\n",
       " 1.7393850063843117,\n",
       " 2.788475491010723,\n",
       " 1.7912832645048304,\n",
       " 2.330989678770308)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time dask.compute(*lazy_results)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that this was faster than running these same computations sequentially with a for loop.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now run this on all of our input parameters:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:55.538037Z",
     "iopub.status.busy": "2021-07-19T14:36:55.537630Z",
     "iopub.status.idle": "2021-07-19T14:36:55.603427Z",
     "shell.execute_reply": "2021-07-19T14:36:55.602603Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask\n",
    "lazy_results = []\n",
    "\n",
    "for parameters in input_params.values:\n",
    "    lazy_result = dask.delayed(costly_simulation)(parameters)\n",
    "    lazy_results.append(lazy_result)\n",
    "    \n",
    "futures = dask.persist(*lazy_results)  # trigger computation in the background"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To make this go faster, we can add additional workers.\n",
    "\n",
    "(although we're still only working on our local machine, this is more practical when using an actual cluster)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:55.606685Z",
     "iopub.status.busy": "2021-07-19T14:36:55.606288Z",
     "iopub.status.idle": "2021-07-19T14:36:55.610854Z",
     "shell.execute_reply": "2021-07-19T14:36:55.610500Z"
    }
   },
   "outputs": [],
   "source": [
    "client.cluster.scale(10)  # ask for ten 4-thread workers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By looking at the Dask dashboard we can see that Dask spreads this work around our cluster, managing load balancing, dependencies, etc..\n",
    "\n",
    "Then get the result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:36:55.613962Z",
     "iopub.status.busy": "2021-07-19T14:36:55.613568Z",
     "iopub.status.idle": "2021-07-19T14:37:04.693840Z",
     "shell.execute_reply": "2021-07-19T14:37:04.694897Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(2.5664358075745453,\n",
       " 1.5789964258345153,\n",
       " 2.508826448170943,\n",
       " 2.478565462410365,\n",
       " 2.694666023301526)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = dask.compute(*futures)\n",
    "results[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using the [Futures API](http://dask.pydata.org/en/latest/futures.html)\n",
    "\n",
    "The same example can be implemented using Dask's Futures API by using the `client` object itself.  For our use case of applying a function across many inputs both Dask delayed and Dask Futures are equally useful.  The Futures API is a little bit different because it starts work immediately rather than being completely lazy.\n",
    "\n",
    "For example, notice that work starts immediately in the cell below as we submit work to the cluster:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:04.698395Z",
     "iopub.status.busy": "2021-07-19T14:37:04.697213Z",
     "iopub.status.idle": "2021-07-19T14:37:05.014969Z",
     "shell.execute_reply": "2021-07-19T14:37:05.015963Z"
    }
   },
   "outputs": [],
   "source": [
    "futures = []\n",
    "for parameters in input_params.values:\n",
    "    future = client.submit(costly_simulation, parameters)\n",
    "    futures.append(future)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can explicitly wait until this work is done and gather the results to our local process by calling `client.gather`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:05.019683Z",
     "iopub.status.busy": "2021-07-19T14:37:05.018491Z",
     "iopub.status.idle": "2021-07-19T14:37:11.942099Z",
     "shell.execute_reply": "2021-07-19T14:37:11.941358Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[2.5664358075745453,\n",
       " 1.5789964258345153,\n",
       " 2.508826448170943,\n",
       " 2.478565462410365,\n",
       " 2.694666023301526]"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = client.gather(futures)\n",
    "results[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But the code above can be run in fewer lines with `client.map()` function, allowing to call a given function on a list of parameters.\n",
    "\n",
    "As for delayed, we can only start the computation and not wait for results by not calling `client.gather()` right now.\n",
    "\n",
    "It shall be noted that as Dask cluster has already performed tasks launching `costly_simulation` with Futures API on the given input parameters, the call to `client.map()` won't actually trigger any computation, and just retrieve already computed results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:11.945216Z",
     "iopub.status.busy": "2021-07-19T14:37:11.944369Z",
     "iopub.status.idle": "2021-07-19T14:37:12.038334Z",
     "shell.execute_reply": "2021-07-19T14:37:12.039073Z"
    }
   },
   "outputs": [],
   "source": [
    "futures = client.map(costly_simulation, input_params.values)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then just get the results later:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:12.042281Z",
     "iopub.status.busy": "2021-07-19T14:37:12.041398Z",
     "iopub.status.idle": "2021-07-19T14:37:12.170714Z",
     "shell.execute_reply": "2021-07-19T14:37:12.170358Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "500"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = client.gather(futures)\n",
    "len(results)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:12.174754Z",
     "iopub.status.busy": "2021-07-19T14:37:12.174324Z",
     "iopub.status.idle": "2021-07-19T14:37:12.177700Z",
     "shell.execute_reply": "2021-07-19T14:37:12.178275Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.5664358075745453\n"
     ]
    }
   ],
   "source": [
    "print(results[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We encourage you to watch the [dashboard's status page](../proxy/8787/status) to watch on going computation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Doing some analysis on the results\n",
    "\n",
    "One of the interests of Dask here, outside from API simplicity, is that you are able to gather the result for all your simulations in one call.  There is no need to implement a complex mechanism or to write individual results in a shared file system or object store.\n",
    "\n",
    "Just get your result, and do some computation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here, we will just get the results and expand our initial dataframe to have a nice view of parameters vs results for our computation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:12.182240Z",
     "iopub.status.busy": "2021-07-19T14:37:12.180851Z",
     "iopub.status.idle": "2021-07-19T14:37:12.213228Z",
     "shell.execute_reply": "2021-07-19T14:37:12.213956Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>param_a</th>\n",
       "      <th>param_b</th>\n",
       "      <th>param_c</th>\n",
       "      <th>param_d</th>\n",
       "      <th>result</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>365</th>\n",
       "      <td>0.585399</td>\n",
       "      <td>0.456730</td>\n",
       "      <td>0.691329</td>\n",
       "      <td>0.769552</td>\n",
       "      <td>2.503009</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>388</th>\n",
       "      <td>0.490421</td>\n",
       "      <td>0.816109</td>\n",
       "      <td>0.322144</td>\n",
       "      <td>0.893845</td>\n",
       "      <td>2.522519</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>0.589628</td>\n",
       "      <td>0.168332</td>\n",
       "      <td>0.033557</td>\n",
       "      <td>0.999766</td>\n",
       "      <td>1.791283</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>473</th>\n",
       "      <td>0.471904</td>\n",
       "      <td>0.014750</td>\n",
       "      <td>0.612368</td>\n",
       "      <td>0.613275</td>\n",
       "      <td>1.712297</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>327</th>\n",
       "      <td>0.484244</td>\n",
       "      <td>0.916084</td>\n",
       "      <td>0.273787</td>\n",
       "      <td>0.638778</td>\n",
       "      <td>2.312894</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      param_a   param_b   param_c   param_d    result\n",
       "365  0.585399  0.456730  0.691329  0.769552  2.503009\n",
       "388  0.490421  0.816109  0.322144  0.893845  2.522519\n",
       "8    0.589628  0.168332  0.033557  0.999766  1.791283\n",
       "473  0.471904  0.014750  0.612368  0.613275  1.712297\n",
       "327  0.484244  0.916084  0.273787  0.638778  2.312894"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "output = input_params.copy()\n",
    "output['result'] = pd.Series(results, index=output.index)\n",
    "output.sample(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then we can do some nice statistical plots or save result locally with pandas interface here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:12.219390Z",
     "iopub.status.busy": "2021-07-19T14:37:12.215766Z",
     "iopub.status.idle": "2021-07-19T14:37:13.241897Z",
     "shell.execute_reply": "2021-07-19T14:37:13.243728Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<AxesSubplot:>"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXQAAAD4CAYAAAD8Zh1EAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8rg+JYAAAACXBIWXMAAAsTAAALEwEAmpwYAABuH0lEQVR4nO19d7wdR3n28+45596r3i3LkmzJDTdwk407xhhswEBCgBgSasDBGBISUgwBk48QIHz5nABOMM2UhBbiguMCuIHsuMq9yEWuki1LsmT1W8+Z74/d2X2n7c6eonvP0Ty/3/3dc/bMTtmdeeed533nHRJCICAgICCg+xGNdwUCAgICAtqDINADAgICegRBoAcEBAT0CIJADwgICOgRBIEeEBAQ0COojlfBc+fOFUuWLBmv4gMCAgK6EnffffdLQoh5tt/GTaAvWbIEK1asGK/iAwICAroSRPSs67dAuQQEBAT0CIJADwgICOgRBIEeEBAQ0CMIAj0gICCgRxAEekBAQECPIAj0gICAgB5BoUAnogEiupOI7ieih4no/1jSnEpEW4jovuTvgs5UNyAgICDABR8/9GEApwkhthNRDcAtRHStEOJ2Ld3NQoiz2l/FgIDOYGi0jqsfWIu3H7UQRDTe1QkIaBmFAl3EAdO3J19ryV8Ioh7Q9fjyNSvxw9uexR7T+3HyAdaNdwEBXQUvDp2IKkR0H4D1AK4TQtxhSXZ8QstcS0SHOvI5h4hWENGKDRs2NF/rgIA2YN3WYQDA9qGxca5JQEB74CXQhRB1IcQRABYBOJaIDtOS3ANgHyHE4QC+AeAKRz7fFkIsE0IsmzcvaEQBAQEB7UQpLxchxGYAvwVwpnZ9qxBie/L5GgA1IprbpjpOSPz2sfW446mN412NgICAgBQ+Xi7ziGhm8nkSgNMBPKql2ZMSqxIRHZvk29PS7gPfvwt/+G3dLhwQEBAwfvDxclkA4IdEVEEsqP9LCHEVEX0UAIQQFwN4B4BziWgMwCCAs0U4fTogICBgl8LHy+UBAEdarl/MPl8E4KL2Vi0gIKAV/Pax9Zg9pQ+vWjRzvKsSsIswbvHQAwICOosPfP8uAMAzX3nzONckYFchbP0PCAgI6BEEgR4QEBDQIwgCPSAgIKBHEAR6QEBAQI8gCPSAgICAHkEQ6AEBAQE9giDQAwICAnoEQaAHBAQEtIj9P3MN/u+vHy1O2GEEgT6B8LM7n8OS86/G4Eh9vKsSEBBQAmMNgX+76cnxrkYQ6BMJX7/hCQDAxh3D41yTgPFAoyGwav228a5GQBcjCPQJBBnNLArHoe2W+ObvnsTpFy7HIy9sHe+qBJRAvTFx4hAGgT6B0EgCVAZ5vnvi7mdfBgC8sHmw1H2NhsCDa7Z0okoBHhitN8a7CimCQJ9AkAGHCUGiB/jjOzc/hbdcdAvufHrTeFdlt0QQ6LsIL2we7CoDo1y4BQ1990Szr33l2piieX7zzvZVJsAbo/VAuewSnPCVG/H+79853tXwRqqhB4HeFOoNgaHR7pnA2w1+pExjAvG6vQ6poUcTYNz2tEAH0FXLUHnIU6BcmsNf/td9OOhzvxrvauxyJKc/KgK9Hg4M22UYGYsFejUaf3E6/jUIwPqtQ/ij796Ol3eOAAAEwmBsBr+874Wm7uv2py2nf96OieR50euQGnplAqjo4cSiCYBvLX8K/7uKnakdxuIuRdcrs4kc4cf4Nrq+Ud0DyaFXK+Mv0HtWQ+8mDnF4TOV9u6fmvYFuF342ii5o6LsOUkOvVcZfnI5/DTqEbuIQJQcn0UVV7wn0yuPm7WhMHE+6nsdEolx6VqB3k9Y1rAv0nhEx3QHRRX3FBrKQ6HkKzc6RMbzhX36He597ubMV202QUi5BoHcO3aShDI8GDb2dKCugJ8rk32wtMnme5ZBHuTywZgseX7cdX752/KMD9gK6SkMnogEiupOI7ieih4no/1jSEBF9nYhWEdEDRHRUZ6rrjyLK5aHnt+DGR9ftotrkI3Do7UVZ+dwOeb5558i48daUGkWzaxNlktodMNJlHPowgNOEEIcDOALAmUR0nJbmjQAOSP7OAfDNdlayGRQNrrO+cQs+9IMVu6g2+Rip6xp6GIytoKwwa1UOD43WccQXrsMFv3yopXy4fnfjo+vw5IbtnvclfujsWl7/z0JMBLQDYwnl0hUauoghe1Yt+dN7y9sA/ChJezuAmUS0oL1VLQeXUHz4hS2GRjzeCJRLe1FWQLeqzcrdqf9zf3N+8BK8Fh/6wQq87v/9zus+287iXIGOEASunZCUS9dw6ERUIaL7AKwHcJ0Q4g4tyUIAq9n3Nck1PZ9ziGgFEa3YsGFDk1X2g61Dv7hlCG/++i347OWtaVLthm4U7RYMj9WxYdvEi91e1qjc6ooo3anZQh6thCwoTbl0scIwWm/g8798COu3DY13VVJ0FYcOAEKIuhDiCACLABxLRIdpSWwtMbqNEOLbQohlQohl8+bNK13ZMrBx6NuGRgEA90ww676+YugW/vNj/3kPjvnH68e7GgZ2NYdu8zIpg8fXbcNBn/sVbnx0fbM1AAAsf3wDdo6MAfDzQ+/GEBO/e2wDfnjbs/jcFRNHKUu3/ncJh55CCLEZwG8BnKn9tAbAYvZ9EYDW1p8twublMlGXmIbbYnfIc9zQtADqLPiEODRaTydyd/r2lNtsNjJaYrOQ/fpXD7+Iz1z2IID2KAU3P7EB67ZOHE0YyNo1gSLWdpfbIhHNI6KZyedJAE4HoPs7XQngfYm3y3EAtggh1ra7smVg79CtL407AWNj0TjUYfnjG7Dm5d4Iv8pf/Rv+ZTle+fe/yU3fqvCTt7drZdWK4vHUSzuSurjT+Nbyvd+7E2//91ubr0wH0MwTFkJgy878Sb0VdBuHvgDATUT0AIC7EHPoVxHRR4noo0maawA8BWAVgO8A+FhHalsCtiWnjWtsFe3wSDE19M6I9H//7Sqc8S/Lrfm/75I7cZqnEU7HRPPK4YL1uU3Fk1TLtW9RoJMmwctmQ5bPXpSLQ/6s3rQTL26JNfPnNw/ibRfdUq5CuwBlJr2f37Uah3/hNx07rzUV6BMglkthcC4hxAMAjrRcv5h9FgDOa2/VWoNtcKVUZxsFUL0hWn6Rw6O7xg/9q796DADwv6s24qQD5hq/6ysFXwgxseisshRKq/1BGmGbzabVR8ef/Whd4Ls3P4Vjl85uOr+Tv3qT8v3+Lj/ebvkTsQPGoy9uw/57TGt7/qOp22KXcejdhHy3rfbBVsx1j6zDlkH/Jd6u4tBPToT4g8+3d4BOOCNuWbfFFkl02fymd3q2KNG5cfORtVvxxatX4id3POdM38zr6qZgdzr6qxUApntwK3jsxW247pF4Y2IanKtLKJeuRC6H2Ma+qQuzFzYP4iM/WoE/++m93nmMGZXtzOCRblXtjhXT6bH+3MadpSbIXb2xqNGiRI9alOi227cPjzV1nwsbtk8M99Rmxm5f4n2ib+BrBWf863J85EfxxkQp0CfCKrWHBbr55uW1VgUaX6LrxUht+9mNO1rIv+lbcyEFV7vz77SG/t5L7sBFNz7hnb5sfXxT3/3sy7j7WfMELHl/0xx6k/VpBkvOvxqfufzB0vdNNIN5GdnZX4vFnE5ttgtyopgIC9WeFeg2yqVdAi3vqC/Z0VrR+jrVLzplvOx0R960YwTbhoo1Tomy1fmHqx7BMy8VT8B/8M1b8QffvM0sr2WjqPq9bD5lFUNpKC7jh/785onlvljmCQ3UEsrFYiO65YmX8OM7nm2pLnLr/0SgHnczgd6a8UrPR/8MZMtn1yqg3hCFHgid6hep4GkzR9Lpjjwy1igV+KqZ+vzVL+4vfY+EfNcNAfzev/1vEznoXi4lBXqTa/0yt43n4du/e3xDS6F+JeViE+i/uHs1vvnbJ5vOG8hkTdFb+8uf34cvX7OypbKK0LMCnY+JT/1XPFjbFQ2P5yK0PiIHiSt877IvXodXf+mGgvw7pEnDr+OVRScFuhACI/VGqRVPM9Vpif9k5d23enPLZbeD6m33Gxkea2D5450N1+HC+y+5E7+v+cOXeV3SVqlPSnc+vQlPrNveslyQE3BRNpfd+zy+tfwpfP2GJ3DzE515lj0r0DkVcuk9awAwb4QWBVCehl6El3eO4qXEwLR55wiWnH+1kabTGrqef+vPo6XbczFaFxCiXB2bEugtOA+Wbf/qTTvx3ZufSr/rRtGyp23tCmPcRTc+gfddciduemw9hkbr+PoNTzTt5toayr/c0eQF7dAMxe/61m14ZO1Wi1NCczXS++jIWMPab79x4xO49cmNxvV2oCcE+o/veNbYoqzPui/vGGFG0daQx6FL+Aj6NS8PFuafh0vvXoNbn3zJLzHLV69bqwK5kxuLpMGpjJBrZsXQilAsu6L64A/uwhevXon1SZ81jKKW+q/etBMPrNncZA1bx7qtsRKydvMQvrP8KVx43eP4j9tb4553FUaTiWebw/NnrMUlkY3K3TY0igM/ey2+ceMqs7yG6JiLY9cL9LVbBvF3lz+UuhBJ6IN65YtbM66rjUZRl/DwESouIeIrID71i/vxnu/ogS9N3PrkSxgcqTsntFYpE58J4abH1hdqdL9++EUsOf9qbGWxV+Q9ZSadXS7QSxYnY8u4JikbBXDyV2/CWy+y8/Otuj2WwVijgcGEumgnr37Ng2vxvkvubDmfX6xYbVBD0q1Q19AlWtXQU2cLNrKk26jN4CpE5zYhdb1AlxbmjdtHlOu64W/t5iHrg28G/H59TEph4tNHXAOxnQrvcxt34j3fuQPnX/ZAlq9WQDuNxDbc/ewmfPD7d+GffpV/5Nk3EtdE7nEiI1GWMeTuasqlbHF6WXo3KCtgrDW3ZNGOldTIWIOF0GhfR71/zWYsf3yDd56uOeyv//sBY2KQlIvLN791Dl39DwDVyG2IBToXJqDrBbqEYVjSOkZdiLSztC7A+Gc7fSEvP7950Hmgxq5QrKS2+/i67ekz0ftv6xp6/v2bk8BITxe4Bo6lUeuybplp6B0W6C1p6M09P3mbPrF3alemXs1mvGPkNndbfq1AtrnobIBmypSUyxDbKcpplrF6qwJdjithXBsebWC03jBWM52Knd4zAt3QlBv678Lbvai4rCwHfXbP+DSBodE6TvzKjfj0pfaNHLtCQ8/Kcm+saicFZS87bmeRJpRuoWbaSzMC3Tctfw5laAudcy37/FINN72g5V9WQ/eseju8kcbqDeuRd61CPtI8GqdZrlv2K97/htjEMVbiRPnRegOrtYBvNg1dFjU0Vsc7vnkrDvrcr5R7OhWZsWcEug5DQ2+0b2MRH28yr3Vbh3DTY+uzVQCArcl29ZtX2Q2XrlfKBc3fX/mw1RPGv65xXkSZFuSiiVotw4Uo6bxF6eSA45qj1NjKjGXf1vDqlFFWzTNg/e8FzCBxetFlKYA8TZvLjXYI4NE6p1zakGEC2TeGcuKt7BjOhH29Ebsd+mDUsvFncCTLqyH8V0UX/PJhI3iZzShaZ9dswc2Chm7B8sc3pPGfdZhUCKdcWlVJzXLe/u+34oPfvysV9g0h0s45UCv3mHn1fnDrM63UVFnWd45yyf+9Qn4CXQ48/n6kQC/zznzb0yyzYZwB26SolNXUBXKehm4TPHmigQsO/bk0I1JG6qIj5xzVU8rFraFvHxlL39n1K9fhXd+6Dbd5uP+N2DR0bSXguyqy+eLbbHNFE0TQ0C143yV34v0Oy7j+QBtCWL0Klpx/tdP67YLqhx7/f35z7ILIPWmkN8CkZOuxmY89/3YuZRtMC5QrS10A5fW9NS/vxKYdI+4EKO68su8WaZ5y6cvfk6Rcyrgt+gv/LF0ZPrnV6JikUVCmhu7WUq0BpixVzw6Czn40OfTiuurgtEc7N8DVPTT07UNjxqS0dovd9ZfDSrloAr0VwyjfKSxRpFQELxdPrN0yiK9d/4TJbTcEm0n1e8rFqeD36+XwuA5SoA84BLqrE9kEUrOrClkEETmjAublfdI/3YRlX7wut4yiqkmhUkRVpktjli71cinRfN9HxfMsI9t0LbJZUSCFmM7f52mLthCwNg8d22TRDg19rCHSmcD3OQsh8PUbnjC4Zz0NkM+hbx82BbpPv5BjUhXo6nMc9eTRbZNgxqGbip4LQUPX4BJCH/2Pu/Ev1z+OJ9ZvV67XBXcp1O8tNyRt1myJ0UwNTg/sdQl01yxuuzratCVeCg13+4s6n/z9Iz9agb/97wcsvxdpI36Ui9T+eLqRJiiXkXoj1crywMspM77adcKUa2VT1941998frvv5fkvhxSeLdjjPjNQbmQ3A856nX9qBC697HB/78T3ONLK+eQJ9h02gezTKtjltUNfQmxxfQoi0Tg+s2ZIeQF+k8QcOXYNraSZ3tPVpJ3ALIZxGwbLj0WbNlhhlXhk7h/M1dFe5NgHhI6BskLcRkXNjlS/nfN0j6/DzFauN6773F9EmUjO98dH1aRAjG/9ZhDd//RYc+NlrC9MpGjoTfC9uGcLmnW6aSdeSmxWUqeFME426hs4NeLbNWTatMRPo2bV2+I2PMj90X2z1iJQp++nwWAPbh8esdR0eaxjGcd6nXMJdjp2GoqE3x6HrECIbT2MNkZ7BWvSsgx+6Bqn96pB8uOnlwiiXFju2urTSNHRp2AOwM+XQ7Y/ZJeBsl5v1lZVab0RsaailaXgMijwU3SKFS1E62cYLr3sc31oexzppxm0R8Juk+Xvkw+u4L9+AE75yo/M+03BXrm6k2RT0uuqT1w7W133jp4x5aOguu0GewB5riIzi8XwnckxO7XefeCnf74tbh3DY53+Nr91gxr+Px7C+uszolCGHQXXUoqGbAr05yqUhzDrpZdkQNHQNO0fsL0/GaxgdM7WoVmK5rFy7FZ+74iEIIXI5dEm5xBp6+yiXZk9bkbvkCNzLRS2Bf33j124uXUbRBJlSPZ5GUQ5Jb/CfVq7dWrKGduS5Lbr6F6+TLZ8yYOycAl1b5MqLbz+QkyM1oaHPmtzn/G2Euy165ZaFOpg64BbochzJ+DaX3fO8kabBVtnpteT7Wy+6BYdc8Gtr3qNjsv9l13TKxVdh0u0VDWF//0XzQ+DQNegvRIdOUSidQadcPMp73yV34j9ufxbrtw1rHLqaLjOKZkLB6eXiNIqa18psfuCQHhNEbo2Qt+exdeVPRi/m4DMtqmw+uoZ+7YNr8cav3Ywr73+hdD1d9QLKerkUG0W3D4/h9At/Z43jnWroDjdafcLl/tc2Dd3WX1LKJWovh84VJd+JTB5OMi1PoAu1b9rcF/kqm18DgIdfcE/yNi8XnTZr1sulIYRBmY2MNYKXiy827RjBXc9sMmK36Bi1zOQuL5cyy/OIKDc4l6Q4hBC5RtHYmJJfFofUMspCUkB6vTlaHei+G4aa8XfXBbo0dj/+YvmJR4eioZe4z/BDtzTrsRe3YdX67fjM5Q8583HtXNa1Rb5asG2Nt/UXqQA04+WSp8nHlEuSzlNH3+5DuSTPQq5AbDYyO+VSXP6oxR3W0NCbpFyEMLXxzYMjhX09aOgJbn3yJbzz4tvweIEmmUu5NCFYZMfh3iLxdW12ZucLyoFo48t4fXS0k3LJdl9yDd2+bG0WRZ23lZOipKYmZVyeMClrrFM19DJ1Mld/OqTwyqOH0vdgaJ1u7dGqoVvyTp9Xjh+6C3ndoZmdolJDn5Ij0HUvF7eGnr+asSGjXLK0bTOKwtTQN+8cDV4uvpC7DotONdcplzozXhgauoem4aJZXEbRsYbANQ+utaaJf2/sEsplNDWKZn7oerGtOj8U3S+rXvbgBsB0W5TCZKwujHNAyw4RVUNvgXKxcag5bZVlZRq6tsrTXpBto5VavlmW7FtUkM6GvHSxQC/3pLckITDyZJh8XlloXtNdtW7h0Mca5jVbneX9/D4lH28OXa+3OZ7isxfy8xk3LxciWkxENxHRSiJ6mIj+3JLmVCLaQkT3JX8XdKS2yDSOIoE+or0g7i9qcMgespIvj1WBrqbjO+me2bjTWp7Mz71TtH2UC9fQXcG5Oh3LJTXGltSChBAYdrgtfmv5Uzj1n3+bGtFseIXDdfHaB9fixkfXqX7oHqpNX9UeElV/nuf9+B7c+Oj6wvx03ji9ztp659OblJ3Mn77sQfz7b9VDE2yPlb93VzpnPH4BfPDEJTh0r+nGb1zw+b5NKdDzFpmyvroxWtl92RDQ5W5DCOz7mWtyy7e5vhobAj37pj6Z8ZAiEi/v9KFcxo9DHwPwKSHEwQCOA3AeER1iSXezEOKI5O8Lba0lg5zlf2SJcaKGxDSXre6t78UvUybRjSC6kLL5i9s5Tru7U1JBA7472YxyUm8HYm6bapp2xnL55M/uxTH/eL36e5McekNkfLVrvPHDMPTB5grFeu6P78GHfrBCecw+Grrc26BryXqzrn5wLf7vrx9z5qOfO2sY1llj3/Wt2/A3bDPXi1uH8NVfqXnnrxDcsVxcEIifhy0CpY1yeezFbfjhrc84lSw5IeVp/rLJOhXC6zzWMIWnj5KQOirkCHRJcz25YTs+/MMV3od3iIb5/LcMjhbWq1OUi5vUSiCEWAtgbfJ5GxGtBLAQwCMdqVEB5IPYYXEr489Qn3Ebwk8jcoFr94rWoN1q29Fp1aDq9tgygGOnaJPnN8qJIGIcul4f/n1aDs/pAh90V9wXe5/8991rMGtyDZt3juLFRIsuS7nUG4LZJLKJiYN/LztEynLofdUIGC6O2e2LbGORdl17QUWrUZug5lE23elc4ZsFIrJTJCOKhh5/vuSWp/HzFauxbWgUHz/tAOMe2Z68cZZSLtq45vc0hLAIYmeWRt68/xk7vJN2ffbyh3DbUxtxz7Mv44T95xp5mZSLqZjtHKkX9vVOGUVLjV4iWgLgSAC2c8+OJ6L7AbwA4K+EEA9b7j8HwDkAsPfee5euLJAXQ1zVnHUjohJtUbvXR3Ph2+bzNxaZPczOoZvahoSdQzcpJB/wmB6Z1mDPa2p/FZP67C6WebDV5a9+cb9xrewioyFEFpzLIQxaOX6NZ+nDC8uyhkeLOfQ8yJKyncvNLf/zYHteej1dTW6I5DdLAqWubNUKxGfkHvOP1+N771+GVy2aqeQH5E/omVHUvfqxui36rK5lPVjWto2HcV2T60nTtwzGBs7ZU+y++QKmgjQ4Wi/sE+NuFCWiqQAuBfBJIYRuur8HwD5CiMMBfAPAFbY8hBDfFkIsE0IsmzdvXnMVznkQ/CEaXi4N905RP4Ge/RfK9eLB6OI4XdqFjUNvNgY3d1t02RDk11qFvJ6FDl/58/zmwZRP1WE17AmRbSxy1KvCNfScMWKdADmH7jW+4vQ+Xi4+cK6YmrA16JBZqEZRz/wgEBFZn4kQWT6poEw+PLdpJzZsG8YT67Zr95iUh46UQ9djrHCjqM3LJSfPF7cMYcO24bR8NS817VhDHRty8j7iC7/BUf8QB6dbtX67Ea47pmBVDI3UC1f947r1n4hqiIX5j4UQl+m/CyG2CiG2J5+vAVAjInO90gbwTqb7tfJ3baVcHA/Za9nWyDplXlQ1Xy+EsYZ784HtsumG6auhs41FbJVhy6tWiZrSDssIoHddfJs9D0sWDQGMaNEWdaHtq6DbeWaWT5rO3Rb5k2kULSpbTZGGz02v60pBuaVMnlFUTef3nhoCANlXP7bdmrJ90qCpC2Ub5fHUhu1Ycv7VaXxxmWYoh3KpWzxa8vrrcV++Acf84/Xpe9PpGyUfLTCcbDtPdvqFvzPKsBlFd7ID2V0YNz90invf9wCsFEJc6EizZ5IORHRskm9x5PkmwDWy/qpaff4QbTtFXWeKyhf9szufw3/fvSa9vnH7sNHhuIail2krl3uXcIzVcygXyzXbBOWDUR+jaFLlWiVqKupcmTnAtRPVGg+jIQpjufhrnfllpiF+c/KT6U23xfxKuBQJV7C4srsWbSs6u5eLNrGwz89t3InDPv/r+NxXERtFbSIndv9NytUEtTQk6kKZr24lbn9qEwDg6gfWKvXVN/wYbotaU8tG1ZTP3OXlIq/qc5nrzITYpqbmNThaLNA7tVPUh0M/EcB7ATxIRPcl1z4DYG8AEEJcDOAdAM4lojEAgwDOFu08EpyBc519mkDnBeqaMjeomLFM4u/nXxaf/fmOoxcBAN558W146qUdeOpLb2KdUu1URRpDfzWyComxPMrF8uj0juu7Sy/1cmF11e+Uz6Ov6tbQ84RMO161nfMtplwUoQyCS19uCIGKJQ5Hdm+MPO1YpjdPLMqH4S6Y/HcZRcuukuxskjlZ6Nnyr1fe/zy2D4/h0rvXJJSLQ0NvCLbSU/NNNXRDoIv0Xgk5KfYngeukHpF38AQvW8JPoMecdT25P4JJLeqyQVegH7AcIyfT689/cLQ+brFcfLxcbkGBA4EQ4iIAF7WrUnngxoQyGroSbVHLU+8kK9duxcELpqd8mb4zVHFb1DLTJ5L+aoVp99ry0UNDpyRKou49w2/97BUP4g+OWoQj955l5MV3HXLDri2vWoWcgjtv4JSRP/o70+vGoWjoMgywIZQtUtmCPKEH+B3CkZ7kXjI4l9G2ktEWi2ClXCyThT7xWtufKCyxUdSeb6qZa0JQCnJTy4aSHsieoQyLIYW97uXC21ZvuL1TipAK9IZArWIqYmmI3eSybiR32X4aNg3dw8tl3I2iEwX8OfRXVY+MIg7dZRTUB5AecVCJuSzUQW8aRdXBPlCLmA+7ms7HD10210YhSfzn7c/h3d+53ZrVKBt0DieXNK9qFDk11HyB7i+AXAGa7JxvZgx2a+h+5dpWNMpcIHeg5kj0jEMvR7kUrS6MnaKlaS/7ZBjXzZ2KP7uIUU5CiMQP3VLnhinIpXCU2vWgFtraxqHLtHKCd1Eu/NnVGw0zuqmlX9q035p2yIrLy0U+MD0HV7hu4dDQC+OhB4EeI5dyYQ/RoFxyNOIigaQMCl1D1ykXbTD2VSOrZpyvoWfX5UAzBXpulZVy4vuzG8yBHV+pJfSQEAJDo3Xl6Lk8IdMQAo+9uM0rVrcrQJNNjtrcFs3gSEzLzClXpONVXW351CPNI/k/PNbAtqFRLDn/alx2z5pCykUXQinl4thYVFpDtz47+cndXpsf/sW/exINASflwle6poYeCz2XUFZjqcSVlgJdpuGKmB610JdDt2m/8lrmE6/+Ppa2Jf6ut9227wUwbWpAoqEXDIWgoSfIp1yyz/qLvuK+550hNov4LtU6ns9LcvfCSkSoRpF1yRnHoLCXx/PPBLp7MOZBPgf+PMyBHf/vq2Sd/umXduAlFtEyT0N/ccsQzvjX5fj8le7IghKuAE22JWq9wTn0+JotloZEvtti/J8/R/4cVm/aiS2DowUcepx+eLSRHgp+8e+e9KBcHNcdNo2yXi55RlG1PHe9DPlCZD8JSWSKiO52ybn0dVuH8ELyjPTfL7tnDS7+3ZPab2Z9BzX3v3rDsiJ2KBr6KqpWUVcCLkVM5v/2b96KFc9sSn/f6TCK2jYW+RhFx3Pr/4QC73h5GrouAIfHGvjlffYY2jZhwq3adU2rU6kddZTwDlarkBpDhd0nDTQ2CBF3uBc2D6YSzDCKaoNzaLSBNS+bh/DK+igxOLRi5XOTnX6sIbBphxqeOG935OaEX7zz6U3ONBIuDd3lZld0pqj/dna5UmmwaxnueHoTzvzX5bncJ/dykVy+EMWUy3/dtRo/ZKEqdLdF/X6Xhl5z+C7bird50LicAQDTNpFnFNU9RXThODRax3u+cztO+MqNynFysr0yaB3Aomla2rx9ZMygN/WybFFIh8caeMVnf6Vcq1ZUDd00isp+hjTdB79/V/q7S0NvCHNCHvRwW6yEI+hiRA63xRe2DOETP703/a7HcsmDzY+ax1sXeqfKWbZzgVGrREoccp62yG3x2odexAlfuTEVaHp7bB3mpH+6ybgml5IjDkEW55XVF4g780ZDoBfHtvARrS4O3UV/yInEJWhNLxdH3VINvWFck1i7ZajAmyf+PzymntpT1O7L7n0el91rnsDjKsvl5aKfkyvhbxRV09hsCOl39iz5qrguMkXEta9h50g9dSi45sG1mRaefFg6d0qaNi9Wj34o9JglXIbvWbtSI9brnuZtEfTbmFLXfg09CHQAqkDXD4649cnM9V2PtpgHm7DYNjxq/V1oM7Jueecrg75KpMRPNzl0e32EENiwTY0iqLfHVzMd86JcTA39ZU2guw7ljuur/s/DpL4SAl2IdCJJw8EaHHpxmTz/kZznAOTbChSBnl7LCbIGmb4OG9fva6SX0Fekab1yjaLCmY7XW9fGibKVBBc+9YZQtNg4H7XsnSN1HLjHNADxkXI6RbNgxqQ0bd4h4DuGx3JXx4C/AVmubqTGX2T70uGKpyOE2f6h0cChe4M/CFcHB/xnbsCx3GMnles7zPSNClyj4uX2VSM1Djmr0pjFYp+VYb5wU0PPa1GGzCjK7tfuzQR6tiw1NfRyGzjKwvYs6oJvLPK/zwaZajSHeorLyRHocuv/aD0VdoJn7sDwqN2jyRUP3U25OPq7JXk6ybJreraqQFd/49+5QG80sv0cLvpiaLSetmkjiw0u0/G5Q2rodoGuToQ2RwLfg19So2iqoau/2zR0jtyQFZYVStDQPaG6LbqrX4ZysT17PiPrW/0VLlwIZXbXKRe+Q9OXcgHMqHJmyFb7vSLhGf/tplV4ecdI6raoxrEW2j1ZfYF44OgaOg9I5drqX9SJ95492e1pZPPUaAjDbTHPD93LKMqe43ObLDYH1rZ1W4eU5y5/UiY3USjPDY0tPVPUwnPz6zrk+7GdPK/DFlnUZQwHzBhJRJTZVtg440ZR176GnSP1dEW3cfsIC59slpuuwCxt2D48pjy3ujDHha/iJp8dD+HBkW39t9+/eaddoP/wtmdwv7bpKN5Y5O4VlYhKHxLii/KxUscZkbeG7q8tWjX0XKOoqjXwWOW6UTSiTPgqAj2XcjE7lu/W/6WfvgYnHzAXNz/xEuZPH0iNPQrVYHg7SA09E+ibdro1dLnbzlbvPFQjck5ENtpreKxh2B9MYZZ9zndbtKxULOAD8dVfugFvO2IvfO3sI5U6xPWS2nVxu4dGdcpF9Yk2aATHy5WOEbp2Z0ttpVy0gvJcPknR0LNx1mCeJlmccfXewdF6qnht3JEdqq7XacGMgULKRaEp68KYeHzjCBUZRYs09M0ODf0/b3/OuCZE/iH2naJbgK7U0LlR1B3qtcwZnFYO3UG5xH7oGRqahj5iMYrK2/XIcTxf/o4FbFZ4XaC7O/LNT7wEIBZecmJTvTvsk0NfNa7EWKNhhIjlW7JddSkU6BVyumraBrQssxpl9+ll8Eh+ecXL+4r6hS5Mr33oRSOP4bG64qFSFIZh2HEKfOqHbly35ycFqxlK2V222lfV35TvOocOsnPoInO3dWnog7qGLuzpB2oVZhQVxop758iY6rYoTC8XX+qxohtFtRtdqyWJrQ6BrkMarl2xX4DO0S1AVwr07HMe5VIGtln+3uc2p5/VZauavt4Qiusi/1xNNHSbwNN3ivJZWwhb8KA43+/e/BRuffIlL756tJ7x9HluizYN3eb2qadPv1u0QR2UuMH5eKtISC1noMbCJzgmo2O/dIMRQ4RD3lW0cnMJU31VlvHfxULFtRprCPtzc/mhn/ua/QAAtSjCqvVZkLPcvsB+cr13wK6hZ5SLahTVhaLNy0NOxht3jFhCBcTp+qtR5sXUEJisxeLfPqxy0bbNgb52m3SnqKPOo6nbokND11asLkzpj9uwfTho6F7gGnoe5VIGtsF26T1Z1EU9QBBPXm9oHDo7+7MSuTn0Ic21ibdLwHTPkmV88eqVeM937vDy7uA77VTvDjWdzQ9dFyr8fkO7EepAtSEiQiWPcrHcLON6DNQqKX+qc5myfS9tH3YXDn/KJc9QDcjomVBWDD7ByWxKg2tjEa8DH/zvOmYx3nr4XhipN3D6hcvT67krE6UNbu1WbwOXOTVtE8y69AQqMx9Zfymo4wOTVYEui5rUV1F2Ak/SvNZiyoXlK8xx4WsUN4yieh+u5/dhlx+6DrlxLk9DDwKdgXNoeZRLGRQF0lH9zlWLt065cD6doGo6vBNtG1I7q66h6wKgDOUiMVLPOGjVLUvXsOP/nGfUjbD8fl2BdHlrcFSIFPpJh609UnjPmFSFEMA/XPUI/v23TxbeZ88//l90lJ/RF5Kv8h3K5bKc8BqiiHAx65kaReU1i0CU0Feh9kMn3DXIC3Wgrzo4OOWiCyBJ6dXZM7BBRu/UD49IKZdqJTWKCgFUNS+e2Cia5R2f8qWW4SvQ9Z2iZb1cfDHVR6B3yCAKdKFAr3RCQy/oFLr/+J/+x93su/o71wA3bBtWNhbxvrKdGXwu/9gJmoZuxpoYNQR6bpXje8ayJWrehpqUcpEcbV0Yfu/8fl17d/kjc8SUi3vA2FgG6YWy9+zJAOIt4zp8x1/qctiihi55bEndrHl5EF++ZmVh+ao2nFxzTIR88tT7uG33pi+Hnke56AKOKyK6oE3vcXiMSExJKJRMiErBHv+f1FdRNo7pp/jsYLtMZTmu1WERqkV+6NpO0WYhNfS8c2DzTl1rFV0n0DvBoRfN8lwG6C+qoS0D+WB8fvOgc2PRjuGxtFMdutcM5TdhXVoW7xTVoQphlr+WTn5PXbuEMDRZnpdr2ZtXJemq5XrUtoG5OgllsDgR6Hk8dCF8NXQXhw5VQ+fP43HtyDUbVOGpCzg1LX9X+u5Qm7ub7yMwbR/8s6ahs3JcIQduf2oTNmwbdr7TyckmMjkm9Il/Uk2lXHRqZ3BUj+Vicui+GnpVo1xc+eStdlw7dTmkHSDPntNBed6FAj0nOJcPbKudIqGgbAceUjncekO1vOtGN2Ibi3jn2874wUpkBtwv2snmw9tyykXJ27H0rqVeLsLgmvPcHn0GQ4VUF04dtoG5etNO9FUi7DGt31rv+JqzSGu65o2i8X+p6ZXxogLU95n1B7VuaR1YO00N3ZJ3LuXC02m/OcoEVCNpnlfGx39yj7N8KdyyWOOqMO2vRcoBJjq1E3sH8fo3v1M03fovVwuW8fVnP70XL2wZMu6VmOoIW6Gk8dDQA+XC0KpRdJolOFSRQNcFsf4b7xvqxiLp5SLLydJtG8r4QZ4GSLxcDM+H8pSLHn6U52/Lqy/lGRuGQOfGXlfd8qokvVyclItVQx/EgpkDmcuZzbDoqZ7agnPZ4KZcVPqhSNM372efNb7WpFzU3cYcVsolp1yed54fut5uZadojma6ZXDU+cykQB/ThGjm5VJRgnPpKwHdcWDMQrn4vv+UcnFo6GMNgSvvtwfvk3AFluNwGUXffuRCvOXwvQDYV1ntQtcJdPVM0Xyj6L5zp+CCsw5JNTwA6K+Z99hOQuFQNXQL5cINN8lg/MlHXo0bP3VqwqGbGiyPQkdEigb3yZ/fh3ufe1kpJzYImVpeHkYdGrp+SXdbHKubboucN3cZbPPqVIlio6hr8Nuub9g2jLlT+yHlibUtvgI9SVakWRdq6Cnl4rk0SKAb1nlZrgkWMJf5tqiruRy6cKfTbUMcRJlR1EW5AMCsyX3O8iXlop8GBCFAlLktxvFwTOPr8GijkHLxPa4vpVxcGrpHPl4CPZnEdIH++kPmY+HMOIZN8HJhIFbjIspl+qQaPnTSUkWARWQOkoZw79qMf88+WykXxSgafz580Uwsnj1Z8ezg+WxPvFzky9U7qjxEV2KsrnZun5DZo3WXhm7X9rmXix67ZcTBxwNuLpijEhGiyL2ycBnW4lWO/RnF97nL5BCIn4c+IevQB7rUcDMNXfVy8YVOHfCy8kSJroDYjaI5lItSB/cqzxTo3LPHPc5mTamhIYSVCko19HRHaaahR0Toq0ZJH43T85VAXzXC0FimoUtbVBE16UJV2/qvz8e6jcoGV6RQDpdRNIqyE6ACh87gCp9rg5yVeYePiDBJ28Cg79qU+NCJS9PfJQzKRetkUvDJevJ46Ho+dTYQivold/+K0xd35JGxhlVY6Lfa/NBzKRddoGuHA9hAidtima3/QCxM9PjhHN5uiw2Bd3/7dvzDVY8o13XfZ5empnu5+JzO5Kqnsbklpw39uoaun6SjbY83oEwkZp1kDH09Dx+jKADMmNSHuhCYYomiOTkRbnLy4wZJqViN1rOxx7n6SckuUr561OnNOO+SGrpltQz4rbjKCHTdb70aZQeGBC8XBoVyqeVXP0oFOrtGZBh5dNpE4uQD56a/S2zVKRfHZJC+PMvGomn91dRt0aZxSUwfqOKez70eJ+4/B1sHR5Xtxz5ybNQRAMwVRjXl0IVFoOeEnXVt1uAo9kN33BcRpDyxG3idRRpY8ezLyvfDF8/Eyn84E0vmTGb5OTL0oFwu/uOjnGXnUi45dc4zij790g4c+vlf46bHNuCQBdNT90612m4l4KkNO3DSP92E25/aaPFD5+Fz3eOsEsXvZXK/SWVOrkmjaKahb9k5itUvD4JAqZCWfYtTEZP7KrGGnnS7viStwaF7a+j5lIuPt8y0gVphmv5qlB5IzRFF2Uozb8y3iq4LzsWfRV8ln0OvWuiMKDI5rEbDfnqQ1I64MNs+pBtF7UIge3lgHHr82/RJtYRDz3+5lYgwe0ofqlGER1/chmO/dEP621suusV5n4TTy0UPzpV8Tzdf1PMFumsw5HkcVCL19CazTi4NnXI1mrIcOofMlf/k1tAl5WL2CYkl7OAG437OBWuGubwm6AKda86r1mfukrUKGX7cet6uch57cZvR//lqypavhDS8x3y5ultXF/J1IXDa//stNu4YQX81StsmwwTw8MADtUocy0Vq6NWoRQ5dPbtU78OuQ6A5fDj0SkSYVKsYK/lqlMUJDZQLg3KmaIGGnvHT2TWbhm4LywlkGj5fXuscuot/jxQNXfJ2iYY+UMX2xMsl7+XK+uctefPg5NAdGnqN8cO6Bsq/62Fl5bMbzeEhMy8X++8uDanCNBvrfb6UiyWdzFY1DuphipP/yXebH3qan8eJSfFnVaiU8X1WNqCx+4jspfOc847xM/3Qs8+uOOx7z56cUiZ6HBYA2HfeVKMcGWc/Ikr729CYqaEP1OJNR7Je1YhQF+7VYREyo2hWFw5+fq4LPpQLAQalG5efUYed1NALBToRLSaim4hoJRE9TER/bklDRPR1IlpFRA8QkXvt2SLKcOg2g2OFTI2v3rBriPL+YUWgm26L1skg5dCzSIGyHjMm1TDWENg5Us/VPmUezVrFR+v5HPrwWB13PbMp/S7jXttCf3Kj6Ae+fxfe853b0+++G4ty/dBdHHolX6A/vm67V0xsW+6phs5+dGWlG0Vt3jJ549TmUeKKtsiRR7nwbsdPGOLQY/kDcf9T05iaro8feq1CsZ1GwCrQJ2v2CT5XRgSLhs459ChxW5RlRcl5pmoZ8llOH6jiqk+chHcfu7e1rlXmksvvkyiKBQT4+aFHEWHW5Pj56hSSfD3j7bY4BuBTQoiDARwH4DwiOkRL80YAByR/5wD4ZltryaDuFM2nXCTfLrSOb8STFnbKRSbjAt1qFM3h0NVDopPOlwyorYOjhZQL0PwJ4SPaxgwJ2dR/vHol3nnxbXj0xThyn9QGB0dMYaX7XXM+2od/zDj0cpRLJYpyVzFfv+EJnPp/f1tYvm0iIUv/cHk72MIjGPnllF+3CFYfysWI5aLE/GEauqN8nrUs79Jzj8c7jl6kXNefP++XLj/0vmoFI3VOuWQ4ep9ZhiKihoumtL99/3+fBpCFuAViLXdotJEaVGVcGNcOz7864xU4bOEMw8gtkZ3GFX/Xn7lOpepYMGPAi3IhALOn9CllyvakSl5hLs2jUFIIIdYKIe5JPm8DsBLAQi3Z2wD8SMS4HcBMIlrQ9tpCnd18NXTdy8XW0WwCRb6AQcavGX7oFss715Z4UbIzTU+MK1uHRnO1b1l+HoeZh5G6MHouUUa5SEG+cUesnciJzqah52nBPjymfCaubNxeLvkcOhCHWChCnoau1EOrn9A+VPIoFyL8xekHWstX3BY1w1wZDZ3P/zqVaAN/rL95ZJ3MxZgkjefPfndp6H0VSkM0T2F8+V1/dzp+/OFXmythRbPKqBx5SESNpZeCWcZLr1XIGj5Xr65LP/I9JNqGtx+1ELeef5q3YjVnarzvhYcymFSrFNaxHSil+hHREgBHArhD+2khgNXs+xqYQh9EdA4RrSCiFRs2bChZVRM1b8pFvaa/GFtYTiAbJDwug22nqLx3IOH0+ftSzhRNNfR4po81dHf9ZTWbplwsGnotitJBLnOVnbmmLYE58jbk+LgOViJKPCIclEuTHLov7Bp6/D+PQ5faq+6r76Jc/vz0A3DOKfvmlq/bVPI4dJ2/5s9Cj+CY9xaWP74B/5PshIxI5+LNiYw/cReHXqtE6SpwUi3TXudN68dArWJscW/oGro2frniIg+Al8bKWiVKXITt7bMpULa89cnUBzLypNcwJMKcREPnE9pArZJ+nxACnYimArgUwCeFEFv1ny23GE9MCPFtIcQyIcSyefPmlaupBRWLgZMjSgW6ajzSNYerHliLz13xsJl/ZAp0HZxymTU5eZHsjdncFjMNfSyXT5MDotkTTmIOXX0N0yfV2GaNZBma0AcZ5WK2N8+DxUdDj4oolxwN3SMmUiHsXi42ykVNKARw5teWm8G5xiwTRPLfNgGrG4uS/z5UlZZXxSXQCxbyL7IYJRGpZ1oK5FMuLqO83BgkhEiVGTUP9bvibUbmRFHRNFoA2ClPrUo4dJcg5jYrG/Sdor7ujrKuvIw8cMqFt5fbGIreVSvwclskohpiYf5jIcRlliRrACxm3xcByA+M0AZEUTzzugRKtrEou1aJzAe6Ydswrl+5DjoyysUt0PkycMakGtZuGVJePOfQpfLHOXTnSe7IJqS8WBp5GKk3jPxnTq6lIl6OH/n8pBZj09DzKBefwUFk+qHf8sRLuH7lOuwYHsOxS2db72ubhp77W/arrS89vm67sZvRRbkA9uBLyhb2pD/occJt0IUi/67bhlwQQqQxU+I8VG2zISzBudjvrhVirRJhx0h8HJ8tjel8oGvo6u865wxkY68vGeeu1Qy3WbnqCqibnN5x9CIs22cWbnpsPX79sDn+ffPW00oNndOzAzXGoY+nhk5xL/0egJVCiAsdya4E8L7E2+U4AFuEEGvbWE8rIiIj5CZHahRlA7YaRd4Uhsx6R46Pal1kHVVq6PyF8XjomYaeUC5D+ZRLyxq6ZaforMm1tD6php50cklFDY2V5dDV3/acPoCvnX2EkU73Q//j792BH9z6DH5x9xqn21i8w671EZDvtphdcwbnkrRUztZ/WUsX56/H9Hn6pR1Y8cym3INB9MmMPwuDcnEIOyGQnvEp0+qUS76G7jKKJpRLw75BzqBclAmIjH0kVYuGviM5yq0v8UN32VrkI3dpv1JDHkrPMI3bdfaxexc6V8g8feQGgVIOnUPuw4jTdA4+GvqJAN4L4EEiui+59hkAewOAEOJiANcAeBOAVQB2Avhg22tqQYXsmynS3y0cejUirxNmZP6AW0OvRKqhZtaUWPNWNRGmoTNNHoh9u3Mpl1a9XJKdopP7KiltNLmvmp6PKMse04SVzctFP/CCQ5dt57/xIByyYLpyTQiRTm4PrNmMqx5Q53s5YXzzj45CrRLhwz9aASBehrcj3Ojl9zxvXJPZchmxdSj/MOBKuvXfPUG4JuCGACqU9Y9V67fjEz+9Fx84YYmzPL1/qBy6/boOAXXVFQt0/rsw3RbZ707KpSIpF3v5eV4uRGa+i2dPSj9LDn1wNFamqlGU2DOsVUmFrkvmTkoFevwcGmwPSJHTgRx+XpQLZZSLkQ+xRB1CoUAXQtyCgklFxKrBee2qlC+I8ukImx96teLe3KJDalouDr2abPHN/HvjFzmmLS1197TpzA/Yx8ul2Z1lcrDNmdqHnZtiTxBuPMviyEjKpT0aeuTQquXkdva3bzeeqRxoR+0zS7kuD9puFd9a/pRxLdPmsvf18k67QM/cFhMO3fI8ivYNNIRABWr/27hjpDDssFqGWSeZzpVPTLlk9dU59CvvewGPvrgNS+ZMxkvbRwzDf8WhUEg/dB6TSKlrjpcL90OX4BuRJvWpGnoWy6U5ykW6VX752kexav12hSYqXgGXo0rmOAR6J7lzia7bKcpBRIqrk47MbTG7Vi2h8WVeLnbKJd69JhjlYsZ64BuLZLrJfZW0bj47RfUJaJ85ZswOG+S27NlTsiUgAQblIg2e8lkOWzj0sRyBrivv1cgUwlKLqzeENY69dJWMhU12vRKRdYJpB2yUyxanQI//S20ub4JzaXI299iRsUaujUbPiQtJbqgmuCW6ACwcepaPdF/dOVJn29M55eLQ0NNoicJKM+njTHcf1qkcHuZ6wLLpSEZbtPmaywnKJTSrUeb3/ou712DzzmwPSJGNqoxRNCJYKZe4jsn/wlyaR1cLdMBPQ9ev+fp1V1KB7ke5zLQIdLk7kqeLiDA/6bx5Ud5sXjqA+yispXOn4IxD56ff5U5RrjHwFYOuocvnxfnWLC93Pe9fvVmtN5mGTIF40Ath7iDkZcbBuLJ7qxHhhc3uU2TaAS5oXt5p5/JF+ozyjKLxf5fG95nLHsTPV6w2rm92lMnztH3ndciTNdc/sg7fufnp9HtEdkVixJFfntuiDH9rE3a6Ym8aRd0umTJssAwLwKMtHq2t4mSb+H8DZO5b8dXQZbV8OfSZk+xBvNJJp4MSveuCc+nw4dA5ahWCb+RT+eBdAl1ADZ87xbKTLCLCC1uGsO9nrsEfLlucXvubMw/CJ39+X+6mGNk03VDnGmB/fNw+eOj5Len3sUQj5LElYuNZ+i1NB2STo+34rDJHrsU+57p2llEutm3iUhOrEIGXVIkIS+a4g161gpRDZ9fclEv8v5b6ods49GTV5Rj4l937PC671+TyXWUCsYD41z88AgtnxfwyF3qqQHfbhn52lzqJ2Fx3gdiILq/zclyCrI8dUBERcMOnXqMIRz4xxwZxKN+5YnLVJ07SdoEnGvqIdFuMqapGQ2DWlD789RmvwK1PvoT/XbUxzU/9oCIiMlRj2a4iQV3EzxtlORJmhtvOoes1dB8vF+WapgHmIfNDt1MuQshYLvF329ZgXtS1D8WGwCgCDls4o7D81AtF09BdG6r0DSNAHLZAXttrxgAAMjh0OWFIYbVl0BQwPvFSJHjsZ4nJydZn2zZxIDM8R5E6IKoR4U2v3BNnHrqnd/kctiMHJeRA5TTIFqe2rK5ibBSUrHXZjb2uVQEQ95/fO3IhjlkSu3VyWTGqUC5uLxedorPINgCahs6uFxlF64mXy37zpmIfNvlyQamPUyK1Hx+2cIa2C1xq6PX0frnKjQg477X7p88EKLY3RWR68sji8lyHeZ5e3lY5SbI5p3MivesFeq6GbvmtWvF3WyzaWCQ5PdlRbEH+1Q0cSb5E2GvmQGH5KeWia+iO+se7YE2BTgBu+/RpuPaTp6QUEJANAhk5UXrTWAV6iQMdeOxnieP2nRPbE4QajU7SQXLg6tp9JYlSt3Rec1r6H7CYJTpsXi7FGrqbckmNoiX3DWzO1dDtZQDqpJLXpedpnK5uFJUYrQvr9nSbl9XBC6YnlEtMg9i0UmVi1saiEOZEwcuUGrqc6GtVSnd0V1LhbZbp4tAJpjOEb/C7MlES81KkO0ULc2kePSDQzSZIbs6miVdLcOjydt1o9Yr50wDE4TS55d0W5F/pK0LmS1YtVYesv86huzQK21J6eKyOiIAFMyZhxqSaQrnIccoPGCCyc7qjJXbWVS0C/feOXJhOJpxykc9siBlFI1LzAoq1KBd8BiFvmS2ODcA8gaI8yiX+X9bNcvNgTujWHLdFnXJxwYx17p4AMp7XLYxnTKrhivNOSH3DZZ46dFsIhxBAv+aHrnLoqscVd1u0bfP30dD15yCVlDzHCoBz6LnJkrRx4je9ck8ctjB23V0wI1beClihtqDrOXTby5hUq2BkrGGdeeOO4Ze37JD6xqIvvf2VEELgn3/zGBqNrKPYKBdb7A1fLk7WX1cG8ygXvdMNjzWUwUmgdCOLvJ4dmxcPvNF65okitfcyR67pXi7f/KOjcPCC6elOUS7Q5apmcFQ9uk9CPoO+nElYbnCxIW8QZtEW1Q5x8ILpWLlWjW4hk2Rb/3Mol5Jzz+YdZTT07DOfZPO6lB62Qe7atZYn6QV2TZ9Mp0+qor9aUa4X+aHbJuSatlOUf0spFyU4V+L6GWXt0Mt3Cksy37OcvF1umdmt5iTnThvj3//oaACxciTHUpEnTjvQAxq6XaAD9qVUNSJvjpN7ffDl4ZT+CpYtmR0fNcUoF5vWrfoNq/mefMBcHLF4prN8t5eLvQHx4R3qKx0Za6g7V6OsHnIQyLgkfKBP66823e3mTO1TVgoz0xg3SNzOsuckDcnDoxnlElm0wzwNPS/qZt5glaXwCf6gPafh2CWzjLQ+JxbJDMtuBNtmMUJnvK12nT1XPqnkGUX1g0cichvuMi3SrV1LgcS9VKxb/1ketkMf8g7vMI2iUeqAYDvKLZ2IcoyiunOBnCyKVuwyS9+NRRwzJ/elciEz3BZm0zS6XqDXKhH2nD6AS889Pr0ml2tSw77qEyelv1UqxeFYJXjnGGCudnLAyk4i+8kUC+Vi26otO8Z//MmrccV5JzrLl/3Ml3KpkF3z4hoBITtaTF4dqTdSASIHpk8wfxfmTR1Q6sGNSvWGUDq9FOiZHzo0Dr1Vge6uZ+blkj3fvmpkFQpCm4zzTiwqigLqA9leXZvjddPdFl0xYUbH1I0/tlO79Pz5z7qwll8Xzcp2dtpkHb/Pdh6nnq/CoRuUS2xQrzspF3c94t9NDl3SfPxZvNNicyl0ifTEhIiHPtFRq0SY0l/B4YtmptfkzC+NooctnIGPvma/OL3FcOiCfuJIVialv/MDpm0bHhQjVpLOtrEmr3xds3DdTxbKJa4DT2TuFB1lnjByEvQ5bgswN1P1VSJMn1RVykyDVkVkxA2ZwoIwRSRXCdm98l3lPTOXXz5vjw3yFy4Ia5XIEAp9lSzkcC3dWGRKT1nvPHrIF6lA1zV0B+WS16XHGg1l1UBk16g51FWdJtCT7wftOY2Vb+bHX4vN20j2C5kPz6IvXQmJ1HtLCJVyUcs0tXZXeyQG2apQ4vw3HuSsp49tJC8JeaRpFV0v0KUBzmZQ4S9AdoJKFBVyZuk97H7Oj6f+q6mGnmje1mVn9jlzD/QrX7bJV0OPD+8wf1MGJ2USXeY/XM8EumyDz+ksAPD6Q+Yr3+dN6wdpXhRcw2kINcCS1NDXbxtOJxpS3lvcnjyhnSfscykXyaGza7UKpVqxnMSXzp3CjKLF0RZ9JuwigSonDj2Vy8uF20Z0jNZVe5LtkJcsn+S/Ynexp1k8K3OHtAk7XlddQZCrxGv//GT8/JzjjfTxTtJMSPOVkY0vTzV0a6vsE55NQ7c5WRTROUraHP0709A7J9G7XqC/a9lifOikpZrLk8mhyw5Xq/hr6DzPvWZmy0spUKNIE+i2Tm0py/fQZ1n/1xyoxo53CvTIpaGrg1PWV3bQ0XrGs8sypw3UvDQJXWDOTXbA8mfPOciGUANB8YnDRhnI9ugGtMe+eGb6OV+g59c/LjcrmGvosyb34U2v3BMNkYlKfev/4Yuy/QTE8ihC3gTF88jV0LkfOuVQLnWh8MREHrsj+WetEnzyX5iMC1tf4f3OReEdvGA6ZiSrPF3x6GPjLPP/d3Ho+Rq6TdRLDb2PRVu0TXRlNhbljhnySNMiul6gn37IfLz72L2VTteXDgbLC4/c2okOnk66HgHZYKhQxuvJ7zpsL6+shv6uZYvxnldnh9/mGUWL6iAV9FXrt6UdlEfLk/99NXSdv5Y+zzbKhYgwNNrAmpez3bG2XaMccsLQnxkPeZon0PPsJfIXLgj7q5FyUAURKbuBMw1dYFp/FQezqJLyOXsJ9AItvmbpw/r3mx5bn37OM9iN1huKALeFZsjyN8vRYTNeFnm5GBp6Qb5EmS2iQtlGtbEGW03aNHRHtSOKV48c0ijK+7Ctu+jKTrOYEPHQuxGSclE3XmRC2DseOnvyC2ZkGrpcllV0Db1AO5bwFuhRJghnT87isZSnXNTB/OzGnTj9wuW4nG1Dz4yi8f8Bx2G7OvRQoenxW5YluyyDx36xhUvg8PFDb5pDlxMau1arRGz7e9yOpzbswE/ueC6uDzuCTo8qafP+cNa5UKDb683bo2xIyunSY3WhUAkR5e3FKNZG+SOtsbGgg0+mU/vt8U3MkjOkGjpl7R6tMw7dsgrM83K57NwTlGvyoGze1210SGTJ+/KPnWCkyys/zttdRrvQkwI9M6jYdvP5HRgxb1q/0qn3ZBp6yu1FWXyJOG/bck2FLc6JC3zM8Vvcfuj249rI8VkP8xuXKQUoeXW8WZpAnznFvnzm/zlcp7RLZH7o7q5aNkCbhBx8DZ1yST5HzMX1v+9eE5elcLnaSiSpRhGd4pPGSbk4bst7UyOahk4odsHj755TUmcfsxgXveeo9HtfNRO6OvjkY3LoljI1DT3NW3NlzTRdcwXunKYIWDx7Mk5J6MvfP3Ih/uSkpQBUDd32WHTKZdGsSThg/jQzYU75cTvcZbQLXb+xyAYZqY3v5ksHLRW7LZ58wFxc+K4jlA6zp0K5yKWgekh0kWEovtf/baoaSPbZraFn91Sj7Gg+pQ6O4lOeW9JJnvXUYz/PnGQ/V1XWT0eRi5+Php43KeQK9OS/7uUif7BRE3LyEMKcnInnUYA8V0tejj6pugSx9AKxYaze8OLQ50/vZ3sUzHym9VfxlT94lXJN3zSj1Il7uRiUi9tLKP5MbLJQxyxfQaVtsuSh5i0Vlvg7f2/9tchIx8FtQEAWaM6GPGEd4qE3CZuGnsUvAU7ef67z3n9+5+H4/geOMfi2uSymuBwMqVFUCs4CLxdeNx9ULEIxzsMxqJlLZp9D63AKBDYRAP600KzJmkBPDFx6pL34v1l2kYtf5ofuTvfVd7zK+VtZ3rOvSuCrFb3OfGeyLvDLeLnINK608rn4anN56W56bIPmtmgqNZeeewKu/8vXsAyhpL/sYyfg+k+9Bjq4C68O3gcGqhWPMLWahs7oHNtqtUhrV/OGUk+lbrWKkc5WL3XydpSTI7R97BOtoicFupxx+U46vjvyhP3n4rZPn2a994T95liX8DNYjOOIdYo4QFf2sg/da7q2hNMEQolNJ+oGm+y6SwhwATNnqhoDPa2PoyzdbdF3JaHHgJexoHVDLGAf9EUThxREec9t/vQB/M2Zr7D+lk+5mNf6GOVCZE7IvG/wcyIBrqFzQWMvW75D13PONhapcGnhRRSKXo7+fa+ZA7FnU/Jdp1yO2nsW5k83A8pJ47SVctG06iIDuKpxk0LnRNpEqqcviuWS0SbJ2GXvSDWKWjR0+d/Sp8ugiBZqB3qTcqlaNHSocVQGHAfDTncEp59huS6NovwILr4rNS5PE+glNp24KBeXb3VE2SDaY9oAVm8yY63neQEAmeZStWyw4TSOhN6ezAXN1GaKBj2HPAfV9xACl0DL31gU/zZzci01MHK3RT0MAaBuEzc19Ph/n2aArETmRqRU+3TUr+rQ0F2+5gR3+FzZlrzvOmfvu7DJp1zUiW1qfxVbh9wHris7mokbRX04dP2DXpf4v3yu/Llzjynb3TYbkKu/5VFpRZ447UBPauhpYCmFQ4//F50aMsWhRdj8aGOjqFBOPXdtqpEoEzXQRrnYjnfT0wAxH2q7XuSnm/pbF3gtpHdp+dkmvswYZN7Pd8H+5i9OST9Lba5aMQeTDc5n4qGhX/GxE7H37HiTTK0aKQNYnzuVAxy0d2HzcokisioP3OBng2vrv1Nmk/tMUZ4fr3ve7zaDow15E5PefwfY2LIaRVkViFjUVM1WkRvLxVFPQ0PnHHqRUTSd5Nzj+s2vWoC/PuMVOO2gPRw1CBx605iiB8MB30yTf6+r87o4Qum26NI09QFbikOPzA5k0xp5WTKW+R7TsuWxz1JR5i+1PJtbm62Jel2mW2J26IOJQ66ils6dggOZ54AM5uR7qkxZDf3ofWbhr86IaZolc6fg949cCMD0ctH7A+eidSpAJlWjEGZGeg4urGzoc3i5NEu56P1Qn7D7tAnEV4uU7bBVS99cxvt+oR86sjNHYw2d5yvTQ0mfV28+fvS6qRy6RWnRyhUsQJjEtP4qznvt/rkKRKqhO1O0jq6kXPbfY2ruOYxvO2IvbBsaxXmv3T+9ph+M3A6klEvDna9+2aWhX/NnJ2PjjmG893t3Wu/l1INbQwde3hE/lz0UDV2pkePeREOXMUuiTLBJqoULx0+ctj9O2G+uUZcZjnNVzXrEGK0LrPzCmYYmPDmJyJh3mAGHayJ2+Vtfqvkky4mlPzlWTdZXnxAUfjyyUy56WFnbMpwHeCtTbxeKUut0jF5uRp3I3/3KlULadoKTvjIsjGrIPxNfxejauNkniuqrGzZdGroNfD8Irx9HDttl1KGTRtGuFOiKNd6CvmqEv3vzIcq1zFe8ffWQgq4hRI6Q1QRC1Z7wkL2mG9cqlk4sdy+6ypIn7qgaenHHl9cbFg29WonbybWPVy+dg+P3m4PVm3am1776jlfZNXTLklVitN6whlaV1yRnX7Sw8X3+LkiBXqsQZPh7XTMEVE23QnbKhQv9yX0VTJ9UM86OtWmZHK6doi4UJdNjouvC1Vwp+JUr+7PtzFmdJuGrG5sA1I333G3RFoFTXXkWTfjJvZbJgLst5kGfVD55+gHYtGMEP7rtWadtw1aHTmrohS0hokuIaD0RPeT4/VQi2kJE9yV/F7S/muVg46r0GOA+M2oRKhXCWD2fctGvluLQLZRLtRI5hRRR7GUDAIcsmG41wrj6fbbJJimHTRyp373itWDmd8oBaswZPW9b2Qc6NmhMZlEYAWBO4jb62lfMw81/81qzDGsu/m6L+82bCiBe/WVBlExBEV/L8rbyuOza9z9wLD76mn2d9XK9yz6Xl4uj/nl+6IAZ4M3Zh9Lf3Xlx9CWnDtkOGNFpkiKHAF4lHstFDwudrfjMa0WUlM3I3u9wkNDvTctIrn/y9ANx2F5xLB+fQ3NkiR1U0L009B8AuAjAj3LS3CyEOKstNWoDbJ1RD0g1baCK+dP7sW7rcNPl1KIIY43skFwbdmiHF5QR6JFFK4kNRPb0FSJ85OR98YZD98TSuVPQV40wNNpQvQdclIvkB6Ee5KCUbTGu2iYdHZmQyBKceeie+OxZB2PRrMnWe47eZxZufXJj6hY5a0of7v/8GzCtv1p4fiWHTaAfssBcDf3hMYtx6F4z8MpFM/DQ81vjepMp+LjgfPTFbXgDO7zaVoNXLpqBbUPmiUS258fh9HJxSCwitwcMEK90rvrESXhgzZY4/6JTejyljtSih20nOGkardr3zbrqikc66UXkcFt0UyBG3vJelqeEbyhh6xhvSjh3TqIXShchxHIAmzpWg04g53lxTfeOz5yOtxy+V2F2c7VDdiWqlXjr/4/veM44r1BiU8L1u/LIg41y4ZqzDtnxl86ND1TOjEosTQE1IQ+34RpMGsrVItB9dqGmeWvPyCXMgVj7ufxjJ+CwhVk0wxmTau6TdjyNoueeuh9+/OFXW+9/ZRI5kdg1g3Jh+Z332v2cm7+K6pb5/Vtvcfuh25NbUqpoNAQOWzgjDfLmDCHAVidpmTmqv9wAVXREYcyh51MuuuKRbuAjuzKh0F1y5Z1TfpxvjDI7tvXJgNdd/uaz4s/CQ3sXXRrt8nI5nojuJ6JriehQVyIiOoeIVhDRig0bNrSpaBO2geUKcVv0Xm/529fiBgdnzzUO18ntmxIj5T5zYuFl02RcKO3lol22xQPJ49+BbPDWbBp6xNPL/Mw8dMjL3EVRF+46KhHhyL1n5abhcL1HXfs6bt85RvwZI68oG/z6BMKb+NdnHKQJFf+62VY9tt+N9+WkFPKFir5/oEhD97U9ZC7CRQLdZy8B+0IqLaXSN+azKaqt3pwyO4hNyoWHLVbHTR7S6CPeJZdHOwT6PQD2EUIcDuAbAK5wJRRCfFsIsUwIsWzePDvf2g7YHpjLbZF33GX7mAJk0azJVs8NwG+W37hdE+iOU+Vt4MZCHz90V9xqH/9XSjtrDN7hs9g1bIKxcMCuUmSaMUWgF1apFFxtNPyty2hmZPYXo/8ornnulZNxzbbCYWChh9Trro1FZMp6fq9+6lUR8+drcNQPE3fBFhfHlib7zEJskE65xP9tvumuWS1v3BchM2aa95QTzn6u062gZYEuhNgqhNiefL4GQI2I3MFSdgHsGnr834wvHf9/xfxp+OGHji1VTl6UP4n99oiNbZK3LaOh863SUpjmaei6tmdzF3RrkepyMo62GCPd3FPAYxYNEtXTor0S3VV00Q7JvLwI5rM2z/gsrptdQ09+c9RHCm791zJ+6Lw/mALd3nczw669HB1HLI6VoKMtypCeb7FrIf+chYKOY7mYE6dPv5YwdvyWmtjdaXVFKA+Zht45id6y2yIR7QlgnRBCENGxiCeJjS3XrKU6mdd4cC4O2VH2nz+1MDa3Dp9t/BecdQj+cNni1DhaRkOXp4UDWZuqkbklX0LvtKnw8hC6htsiG/DpgR4WLclrsoikhs6DpdnTNoui1YGEzyTMN6kYk2QEHLZwOk47aL41f586AMWUS/p8tN9zNoo6yo3v0G08xScWEf7+rYfiH69eiVcvne1Md+zS2Vjx2dMLbUS666GtHTqFku0SVjl/m4dQqpC42pOzsipCXkrSxk0edgWHXijBiOinAE4FMJeI1gD4PIAaAAghLgbwDgDnEtEYgEEAZwsfQqmDsM2oUpbYvBZs131QxEMC8S60wxfPxANrNgNoXkPnXhG+m5isxiNHWZnhMv5erVCamO/YM/L2oBzkVU65tLuD+GroPpMwnwdtRtGrPnFyln+TAj0LFWG/Jx38hbnHsB1Ikke58DpxN1Cuoe83byou+cAxhWX7GPx12qRIRBBpXi4aHcPrqn92lQ8wSlFLf+m5JziDhxm0l2IU9ZcbLhqtnSgU6EKIdxf8fhFit8YJA9vke9IBc/HzFatTv9E0bcEGjzyU2c0nj3QbKqWhM4HOgguVnXz0oEfWNOkPpoZuO8SgjOuYTFPGKFoWvhy6zyTMKRebH7otbR7yBLqLAlo0Kz4ha49pft5RR+49C5fe87xyjeetC3TedxfPzryN8sI0tIKIyuUZb0TKVjFWZULR6BOB7ehWetH6c8+jjPTJlxdRQN0ryGi0zkn0rtwpWgSbpviWw/fCKQfOM4JHFR8u60aZyInTkh2U5TT07PXwTuxiDfQmyO82Qawjo1zi/3zA244Zs02ERSuHMUuwtE6jGQ2dUy4Gh+5Y4en4748eb93RmN0X/3dRH396yn44aM9peO0r1GBPLsER0yIaT57DoReHUsj9uTSI1JjmPq+fP7+i4FxF87QhREs0MJvg3fCiXHZBn+9Jge7Stq2RAC3LN1/4aHsS8sQW3X0sDzbKJc8PXYd1WV+gRTdSt0Uu0C0DyKol2ZEK9IZ54Ejb4GyX+r2UUZRsfuj53yWWLcl457zzNjkNcfCC6Vi5dmt6j+TpOSb1mX3uq3/wKqsrZh7l4ppIfIRXMyiroRNldeSHmAOcQ2fpUw3d3q+aWYFneceYNaUPe80YwOfOysKKFPm/c6RpOki59GS0xTJLmrIc+gCL+1BGQ5cBgHw2MkmU5dB1cMGUXnMG54r/y5g3fLKyauiWycK9nTy+rnDo46ah+1AuSdtgGs8MDd1DUtiey8F7xl5Ph7IYPtf++clGOh1vPXwhPpychSnxrmMWAzCfaR7lUrw7sj1SR578pe/2LHr/hMzLRY+VZOvXxR402nssqLft3lolwq2ffh3e+MoF6W9nHDof7zh6ES446xDX7SnkZNNBed6bGnqZvmgzHLpw52dep8R9KKOhExHuv+ANmNyfHzeCQ6VckjIrbj90o8y07OxakQ8790OXSe1GURjX3Bx6/J9H5GsHh/6Rk5diTmKQcz0Sg0P3olyS/2S2SY/M5+flYl47/ZD5+M3ep2D78Bj+8/bn0uuvP2R+rp2lEhE+eup++O4tTxeWqwh04SfQbX2mFew7dwo2bBvG4EhdoYCKVmjcD11Ara9VQ08+u3eKqt/L9L68Z9FfreCf33l4idzaN1nasNsLdLIIJhf20I7gKhvi1LVByQUu/LPDm3OCcxk+0ubqw8X4pLvgUj/0iGkmbm3cdnaomXdnNHQeUVPWdcGMAazdMpRe171QfCbhlIaD2S/0A6l9+o1tAFeIcOD8abh/9Wbl+nfet8yjfr4rtCzd6QerXLxToLPVSTtw4v5zccfTm+JTvUrwAbEfelyLhoB9D4SHh5Xv7zbI8NjtMhB3y07RCYcyL0AO+GbeWZlAW81gcs3FodvT67sIbXyoLW41z98WPrcvWZVwIVyKckku86BYPuFGy0CWfNy+c/DMV97MDojQKRd/ARwb8tT0unugz2rJzqG7fysCv+X0gzOeXX+isu7TB6r42tlHFtaJo11v57zX7o/vvX8ZTj1wXjkOHawPagdKWPdAIE1qz08r2qcmkWX8tALRDTtFJyLKPC9b8HpflNlt1gz4Jhi+3dlbQ0vvzdK7jLLGTtHItBVwmsR2rJyrVjLNh05cmhqU2r71Px37ccYnHxBvVtbfURmjaNRByiXPA6YwP5bhd9+fafT65jn5f+GsycZE5DSKpnmVr5cNlYjwuoPnKxq3D7hni4A9OJctWFxRcK4y7So6rrIsdoWG3pOUSzNxGprzQ88Gt344dLuhxnIpt+TmyUddQZRSDjLudfxUdKntNiwauq2OZj2S3yPCYdII2CmBnnz/tz86Ci9sHkRNE8BeRlH2ydiIZhhJi+uW96yaWc4X3VOJCI16diCJrW87jbmd1B45h16QlijzQ29odE2ZPRDp76VqGqNimThaQbaxqHMPuTc19BLPq7Wdotk9PMxrO6Dvvss4dPPgYgmDQ5f/WdtcAl33Q68xakcufbkhy/a8ijh0XpdObywaqFWw77ypxkD2WVXxibAoeRmN31aPVikXDpH+Ttb/tvLdaL8bklIPj+yll4uP22KmgeevQMvJhvh/+yiX9uZnQ48KdP9HZvPW8EVZo2gZrPjs6cp3vhHFVdeBmp0O4Kn1o8j0tNkh0abbosqhm3kUbf3n97VboEvo2Trj2+SA2x6K3BJbjeXSzMrQR0PneVs1dI931W6UbWumoavvzebIUKihyxVciW7XirJng9gFnEtPCvQyaGbmlui0UZQj80O3e7l8491HYt/kGDUJG500WsCh23aKZpQL59DLTJrmwOtULBc9X8MY5uOVwra/+55VmYf50wfw9iMX4oxDMwNmKzuUXffoB6Hn2YeKNPROzLdFwblc6YVmFG3lTNEySCf2NgngTEPvnETvSQ69DDI3rdYol05D5dDN3/M2LPHO7vJy0Y2KVYsfOh+Ezdgpkm9JOd63t4Rm3lDEBnLRK/Z5DpWIcOEfHgEAWHL+1aXvd9UvrzyAH4jsTqOjzM7HsiijBAD6TlGWj2UybMd70tGK4dqGUw+ch75qhA+euKQ9GVqw2wv0iey2yJF6uVSIaXf53iK2uNGjBZRLdki0SbkoGnqJ50XKYIz/d0qeGxxqi5pZUTTFVpfjzXDoRffoNKJNe/Whx9oNXm2f0A+ZH7p6CHtTwbnKVtZRTivYY/oAHv/iG9uSlwuBcmmCW5PoJIeuQ2o3XEMv6mjpGOAaeiPfKLp49qS0HIla1RwsZewUfPWzYEac/2la0KlW4dIsmxmMaXAui5eLjlbn9OaoABflogXgaoGn7wjlUsLLBWDGeNi1cVVrz8/LDLJWXH4nvVE6hd1eQy+7DOQos/W/VXAhrmoO7qFh49CLjKK/+NMTcN/qzcpzsXHo5c5kzD7vOWMAKz57OmZPzj/XsyzSIlpX0NObiHyMba0N+nZpf4Dp5VKx7BUoQub73X6JXvZZKbFcWCeynrearvzs9W7mMbfiMDFe2O019FbeVZngXK3C6odeJGyYpinhcluUg2PPGQM487A9lWu+Xi7OemgPee7U/pYmUnsZ8X9zt2wzHHUmMIpXQbuecgGAT73+QPzPx+17H3QvkDJFfPOPj8b7jt8HB+4xral65aFsW9NVotBDTJjtKg4HHP/+e0fEtqbj951TWH4rDhPjhaCht/C2fI4zaxdSrauS+aEX1dyqoTu9XNz52Dn05jT0TsHFoTZTNrH/RYuwVtvWbPf7xOsOMC9q8Vkzt1X/QpbOnYIvvO2w5ipVgGYFuh5t0aY5y09FVNGrk9AQPkhXAh21LLQXu72G3sqAHD8vFz9jTZmdonl51SqmsCzn5dL55+TyM25mMHKjaMc19A48G30i34XMYC7OOHTP9LMPR69w6BbKReXV48+uY+SagU0hmuiYIK96/JDFgCjPGe5KLxfZubgfelFHSzVN1vGdXi6Wpsi75BF0zXq57Aq4qtMKF0wonoxapY46waHLHG2Cbzyx/x5Tce/nXg/A773wnaL2WC5ZWvn57GP3xp+esm9b6tuNlMtuL9Bb0R6b5T9bKauMl4uNanf7oedp6DYOfWL2cl1QNBMEjMfc4K944cxJRtpWu0C7bQmAv7vdd963DL/5i1PaXn4eyvQblXIxBbotfG6tEuHjp+3fjqqy8T0x+7oNuz2H3i3IPBfISqXYIH8uE23RBj6w0rwnWB931aeZEAOppssolzlT+nDFeScaaVulTDqhE0jX1Oxwb3shrz/EPOKu06BEhfR5LdlOUXUFmR6YrvimszLa1DkD5dLFaMXv9p1HL2pfRRxQY7kk1zzjjPD+/bdnvgKT+yrpafLZeaHm/fI+GbFQKL9NzF6uv0c93K1fHvKosKyNxyyZnR6nxmE7y7MM2kq5JPXeMRyfeDQ9OZh8V64ki1BmAsx2iqobi2Qe8pxeQO2P7Wpu3sasiYrdXqC3+qqe+tKb8NV3vKotdckDMQ3dFnTLfk/8nwuNMw9bgEe+cGY6WAaSwytyjaLSH7jdQczbisyAxjFtoIZffbL4rE4OrqFn9Is97XztFKuyaKewlfUeTI6wm9Iv323bimgZRXHLOXg8dFvEzknKATBmGa0iL3TCRMVuL9BbRRQVB3BqB1QOPdMc9rBojRKpH7qlepJ66U8GRV4TKhbKZaLB5eUCAAftOd28mAN+mG/RKTOzSh4rqPPwnew6U/qlBjtxJFLaXh8vF+WQaNPLxXX4ebueKfd26hYUcuhEdAmAswCsF0IYDqoUP9WvAXgTgJ0APiCEuKfdFd3dkcVyiVIOMSLg+k+9BoMjjkOF0w5p9kh5CrykJPLc+7j72ERFVvvWa8mjFmYRT+3Pp+xkfsOnXqPYMdrptqhPZlMTgd5NGiZHhbnLVhx8uQR/jO3S0Jvx4x9v+GjoPwBwZs7vbwRwQPJ3DoBvtl6tAB02P3QiwvSBmnPZn0YNtPwmhcqkvjwNPaN5gIlNuaSxXNpQRYVySQtoPV8gPnhjan+mR3XSW2hKKtAnjkCSYSQ+4eGJUlUol+x60eEq/FefHaE6XrVoBo7aeyY7ZrF0FuOGQg1dCLGciJbkJHkbgB+JeJ16OxHNJKIFQoi17apkQGwA6qtGmDe139v6zuN665AaujwUI08QSg594opztlOwDXkV8ebtRDvdFnWXzVSgTyBiNYrIe6dmRqMJZSW0YIapwNjcGo/eZxZ+8KFjMDTiOHbRgSuTkApvveiWpB7dI9Hb4ba4EMBq9n1Ncs0Q6ER0DmItHnvvvXcbim4d3fKuZk7uw63nn4Y5U/qwdssQgBJ+6FYOPe7k/YlRNG+jB3cfm6jgg9+G2z59WtrWImS2Ar/O8bu/PhWbdox4pd2VmCJXX11EGXBE2qrrwyctxesOnm8NucFbGEWE//n4Sdhn7mT0Vyve791VfjdRVu2Yu23NtY4qIcS3hRDLhBDL5s2b14aidy/MndoPIkoFjq9At3VIXUO3YfaU2ODHd4oetffMkrXeNZCTjmv37oIZkzDb08VQ9XLJDKQu7DNnCo7ce5ZvVXcZ2n1Aw66GrLbs75896xAcv5+dQtHHwisXzUjdNptFRll2zwNsh4a+BsBi9n0RgBfakG9p/OCDx2DV+u1N3esTcH+iwJcSyDq5mVBy6AM52ssPPngsbli5DnsmS9yGEPjJR47DjuGx0nXuNE4+YB7+9DX74iMnt2Hbt0WId8Oy29WFJxKHXgYDiQdW3mT5rmWL8F8r1nRk0urGrf/tEOhXAvg4Ef0MwKsBbBkv/vzUV+yBU0senDDR3tUFZx1S6NssB66vD7MtmcxjoOYW6HvNnIT3Hr8k9aIRIk6fd894oRIRPv3Gg9uSF48rvgvO9W0bdHmereR2fV3agSn9VVz1iZOwdO4UZ5ovv/1VuOAth3Zkwo26cIXj47b4UwCnAphLRGsAfB5ADQCEEBcDuAaxy+IqxG6LH+xUZXcHfOikpYVpFs+ehD85aSnefWy+HSILEeDukf2ScslZoEi3xSMWzyysWy9AevPYgj91A67/y1MgBPDAmi0AumN14cJhC2fk/l6JSPEaaifSibB7Fu9eXi7vLvhdADivbTUKKAQR4XNnHVKcLvmfp6H5aNu1SoT/+fhJWDJ3smcNY+w7dwqeemlHqXsmArhJtBMn93QMSVX3mjkJk/uquG/1ZgDdNRlNJOjn7HYDQnCuBF30zrzhs9T2jXXyykX5mpINV37iJGwdHC1933iDR1vsJspFQj/soxMx13cHZAK9e6TDbi/Qu3k5WgSftsl4GJ3oslP7qx1bDncS3MsF6eeJ30/0MAW+3lABdkRdEPJCxwTachDQbqQUYE5/nIgGzvEGj7bYRWM5RSbQ1e8B5ZAeadpFfSAI9B6GrqnZ0Ex42d0FfOt/N8nElHJJNfZuqv3EgVzZ1LuIRA+jOUE3zcK+SOOb5KSRGno3+eF3Gg3mhy43Up11+ILxq5AnDthjGgBTQ+9Wt8XxRuShEE00dB/B2Wb0svLiR7mEOV1HGm0xIuw7b6p37JHxxn9++NV45IWt7MjAwKG3AupCL5cwmnsY2Th298jqRIrcNEHQjTQLAMye0oeTDpibfrf50wf4o9KFXi5hNCfoKn9jT0guNU/DiIr3Fe12KBmba8KC73gNKA85NoJA7yL0cldPhXVOf+ymwEO7Cg3m5dLNkPaRbnQdnQjoRsolvOkeRqahd7ZHXvcXp2Cn69SkLsQ7j16E/7n/Bbz3+H3Guyot4Z1HL8LLO0fwoROLw0kEmEgply6S6EGg9zKkH63lp9/99al4/uVBrN82HKdpoc8eMH9a8zdPQOwxfQC/+uQp412NllGtRPjYqcUnAwXYIaOMdtMKp3tqGlAa2QEBprTeZ84U7DNnCn553/O7uloBAV2BT73hQBywx1S87uByEVzHE0GgJ+giu4c3fNwWJXqw+QEBLaG/WsE7ly0uTjiBsNsbRXvZpys9ls1DXIeNRQETAYcvnolpA0HPbBa7/ZN7y6sW4LJ71uCjr9lvvKvSdvho6GFbeMBEwi/PO3G8q9DV2O0F+szJfbj8Y73ZifRDdgMmJs45ZV/MmNTa+ZcBAUAQ6L2NErEogswfP3zmTe05Oi8gIHDoPYws6l5emoCAgF5B0NB7GH/x+gOwdssgzjxsz/GuSkBAwC5AEOg9jEWzJuMnHznOL3HgXAICuh6BctnNEZxcAgJ6B0GgBwQEBPQIgkAPANCb4YMDAnY3eAl0IjqTiB4jolVEdL7l91OJaAsR3Zf8XdD+qgZ0At0eIjYgICBDoVGUiCoA/g3A6wGsAXAXEV0phHhES3qzEOKsDtQxICAgIMADPhr6sQBWCSGeEkKMAPgZgLd1tloBuxphN2lAQPfDR6AvBLCafV+TXNNxPBHdT0TXEtGhtoyI6BwiWkFEKzZs2NBEdQPajeDlEhDQO/AR6LYhr+tz9wDYRwhxOIBvALjClpEQ4ttCiGVCiGXz5s0rVdGAgICAgHz4CPQ1AHhQ4EUAXuAJhBBbhRDbk8/XAKgR0VwETHhUo3i+7qsGh6eAgG6Hzyi+C8ABRLSUiPoAnA3gSp6AiPakJA4rER2b5Lux3ZUNaD9ed/B8nHvqfvj7t1hZsoCAgC5CoZeLEGKMiD4O4NcAKgAuEUI8TEQfTX6/GMA7AJxLRGMABgGcLcKJCV2BSkT42zMPGu9qBAQEtAE0XnJ32bJlYsWKFeNSdkBAQEC3gojuFkIss/0WiNOAgICAHkEQ6AEBAQE9giDQAwICAnoEQaAHBAQE9AiCQA8ICAjoEQSBHhAQENAjCAI9ICAgoEcwbn7oRLQBwLNN3j4XwEttrE43ILR590Bo8+6BVtq8jxDCGgxr3AR6KyCiFS7H+l5FaPPugdDm3QOdanOgXAICAgJ6BEGgBwQEBPQIulWgf3u8KzAOCG3ePRDavHugI23uSg49ICAgIMBEt2roAQEBAQEagkAPCAgI6BF0nUAnojOJ6DEiWkVE5493fdoFIrqEiNYT0UPs2mwiuo6Inkj+z2K/fTp5Bo8R0RnjU+vWQESLiegmIlpJRA8T0Z8n13u23UQ0QER3JgeqP0xE/ye53rNtBgAiqhDRvUR0VfK9p9sLAET0DBE9SET3EdGK5Fpn2y2E6Jo/xCcmPQlgXwB9AO4HcMh416tNbTsFwFEAHmLXvgrg/OTz+QD+Kfl8SNL2fgBLk2dSGe82NNHmBQCOSj5PA/B40raebTfiQ9enJp9rAO4AcFwvtzlpx18C+AmAq5LvPd3epC3PAJirXetou7tNQz8WwCohxFNCiBEAPwPwtnGuU1sghFgOYJN2+W0Afph8/iGA32PXfyaEGBZCPA1gFeJn01UQQqwVQtyTfN4GYCWAhejhdosY25OvteRPoIfbTESLALwZwHfZ5Z5tbwE62u5uE+gLAaxm39ck13oV84UQa4FY+AHYI7nec8+BiJYAOBKxxtrT7U7oh/sArAdwnRCi19v8rwD+BkCDXevl9koIAL8horuJ6JzkWkfbXXhI9AQDWa7tjn6XPfUciGgqgEsBfFIIsZXI1rw4qeVa17VbCFEHcAQRzQRwOREdlpO8q9tMRGcBWC+EuJuITvW5xXKta9qr4UQhxAtEtAeA64jo0Zy0bWl3t2noawAsZt8XAXhhnOqyK7COiBYAQPJ/fXK9Z54DEdUQC/MfCyEuSy73fLsBQAixGcBvAZyJ3m3ziQDeSkTPIKZITyOi/0TvtjeFEOKF5P96AJcjplA62u5uE+h3ATiAiJYSUR+AswFcOc516iSuBPD+5PP7AfySXT+biPqJaCmAAwDcOQ71awkUq+LfA7BSCHEh+6ln201E8xLNHEQ0CcDpAB5Fj7ZZCPFpIcQiIcQSxOP1RiHEH6NH2ytBRFOIaJr8DOANAB5Cp9s93pbgJizHb0LsDfEkgL8b7/q0sV0/BbAWwCji2fpPAMwBcAOAJ5L/s1n6v0uewWMA3jje9W+yzSchXlY+AOC+5O9NvdxuAK8CcG/S5ocAXJBc79k2s3aciszLpafbi9gT7/7k72Epqzrd7rD1PyAgIKBH0G2US0BAQECAA0GgBwQEBPQIgkAPCAgI6BEEgR4QEBDQIwgCPSAgIKBHEAR6QEBAQI8gCPSAgICAHsH/BwFNlX3QG5DKAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "%matplotlib inline\n",
    "output['result'].plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:13.250814Z",
     "iopub.status.busy": "2021-07-19T14:37:13.250398Z",
     "iopub.status.idle": "2021-07-19T14:37:13.256449Z",
     "shell.execute_reply": "2021-07-19T14:37:13.256873Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.013447214871467"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "output['result'].mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:13.261721Z",
     "iopub.status.busy": "2021-07-19T14:37:13.261306Z",
     "iopub.status.idle": "2021-07-19T14:37:13.284801Z",
     "shell.execute_reply": "2021-07-19T14:37:13.286692Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "252\n"
     ]
    }
   ],
   "source": [
    "filtered_output = output[output['result'] > 2]\n",
    "print(len(filtered_output))\n",
    "filtered_output.to_csv('/tmp/simulation_result.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Handling very large simulation with [Bags](http://dask.pydata.org/en/latest/bag.html)\n",
    "\n",
    "The methods above work well for a size of input parameters up to about 100,000.  Above that, the Dask scheduler has trouble handling the amount of tasks to schedule to workers.  The solution to this problem is to bundle many parameters into a single task.\n",
    "You could do this either by making a new function that operated on a batch of parameters and using the delayed or futures APIs on that function.  You could also use the Dask Bag API.  This is described more in the documentation about [avoiding too many tasks](http://dask.pydata.org/en/latest/delayed-best-practices.html#avoid-too-many-tasks).\n",
    "\n",
    "Dask Bags hold onto large sequences in a few partitions.  We can convert our `input_params` sequence into a `dask.bag` collection, asking for fewer partitions (so at most 100,000, which is already huge), and apply our function on every item of the bag."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:13.290732Z",
     "iopub.status.busy": "2021-07-19T14:37:13.290312Z",
     "iopub.status.idle": "2021-07-19T14:37:13.558579Z",
     "shell.execute_reply": "2021-07-19T14:37:13.558170Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask.bag as db\n",
    "b = db.from_sequence(list(input_params.values), npartitions=100)\n",
    "b = b.map(costly_simulation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:13.562361Z",
     "iopub.status.busy": "2021-07-19T14:37:13.561957Z",
     "iopub.status.idle": "2021-07-19T14:37:23.773917Z",
     "shell.execute_reply": "2021-07-19T14:37:23.774255Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 726 ms, sys: 82.9 ms, total: 808 ms\n",
      "Wall time: 10.2 s\n"
     ]
    }
   ],
   "source": [
    "%time results_bag = b.compute()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Looking on Dashboard here, you should see only 100 tasks to run instead of 500, each taking 5x more time in average, because each one is actually calling our function 5 times."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-07-19T14:37:23.787559Z",
     "iopub.status.busy": "2021-07-19T14:37:23.787112Z",
     "iopub.status.idle": "2021-07-19T14:37:23.801295Z",
     "shell.execute_reply": "2021-07-19T14:37:23.800953Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.all(results) == np.all(results_bag)"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
